#! /usr/bin/perl
#
#	--file <config_file>
#		where <config_file> is the filename of the context config file.
#

use Getopt::Long;
use File::Copy;
use Cwd;

print "Entering configure process of YARP hardware support...\n";
print "This is possibly the most intricate piece of configuration in YARP.\n\n";

$yarp_root = $ENV{'YARP_ROOT'};
if (!defined($yarp_root))
{
	die "YARP_ROOT environment variable must be defined!\nto point to the path of the yarp source distribution\n";
}

require "$yarp_root/conf/configure.template.pl" or die "Can't find template file $yarp_root/conf/configure.template.pl\n";

my $exp_os = check_os();

#
# Need to generate the appropriate newline!
#
chomp ($ver = `ver`);
chomp ($uname = `uname`);

my $nline = '';
if ($uname =~ /CYGWIN/)
{
	$nline = "\r\n";
}
elsif ($ver =~ /Windows/)
{
	$nline = "\n";
}
else
{
	$nline = "\n";
}


print "\nReady to start...\n";

my $config_file = "$yarp_root/conf/context.conf";
my %options = ();

GetOptions ('file=s' => \$config_file );

if (-e $config_file)
{
	copy ($config_file, "$config_file.old") or warn "Can't copy $config_file, old file might be overwritten\n";

	load_config_file (\%options, $config_file);
}

#
#
#
my $os = $options{"Architecture<-OS"};
my $robotname = $options{"Architecture<-Hardware_Name"};
my $cur_dir = getcwd;

#
#
#
print "Now I'm going to ask a few questions that I need for configuring the device drivers.\n";
print "Your \$YARP_ROOT is: \"$yarp_root\"\n\n";
print "Please, use always the forward slash as a separator when indicating pathnames!\n";

print "I determined already that you're running on a supported OS: $exp_os\n";
die "Cross-compile is not supported, the auto-detected OS must be also selected\n" if ($os ne $exp_os);

print "I also imagine you've compiled YARP_OS, YARP_sig, YARP_dev, YARP_math, I'm not checking for it so please ";
print "make sure you've run \"configure.pl\" and \"build.pl\" for YARP_OS, YARP_sig, YARP_dev, and YARP_math.\n\n";

print "You are going to provide information on your hardware configuration here. ";
print "If this procedure isn't clear to you, please, have a look at the documentation.\n";
print "Once more you are on a \"$os\" machine and configuring for something called \"$robotname\"\n\n";

print "These are the standard flags for compiling the library:\n";

get_option_hash ("Compile_Robot<-Lib_Clean", "FALSE", "Clean first: i.e. rebuild libraries?", 1, \%options);
get_option_hash ("Compile_Robot<-Lib_Debug", "FALSE", "Compile debug version?", 1, \%options);
get_option_hash ("Compile_Robot<-Lib_Release", "FALSE", "Compile release (optimized)?", 1, \%options);
get_option_hash ("Compile_Robot<-Lib_Install", "FALSE", "Install after build?", 1, \%options);

if ($options{"Compile_Robot<-Lib_Clean"} eq "TRUE" &&
	$options{"Compile_Robot<-Lib_Debug"} eq "FALSE" &&
	$options{"Compile_Robot<-Lib_Release"} eq "FALSE" &&
	$options{"Compile_Robot<-Lib_Install"} eq "TRUE")
{
	print "Asked to clean and install but not to rebuild anything, I assume debug compile\n";
	$options{"Compile_Robot<-Lib_Debug"} = "TRUE";
}

get_option_hash ("Compile_Robot<-Tools_Rebuild", "NO", "Would you like to recompile the tools?", 1, \%options);

if ($options{"Compile_Robot<-Tools_Rebuild"} eq "NO" &&
	$options{"Compile_Robot<-Lib_Clean"} eq "TRUE")
{
	print "You're rebuilding, you need to compile the tools too. ";
	print "I'm doing it for you.\n";
	$options{"Compile_Robot<-Tools_Rebuild"} = "YES";
}

get_option_hash ("Compile_Robot<-Tools_Debug", "FALSE", "Would you like to compile the tools with debug enabled?", 1, \%options);

print "Browsing through the list of available device drivers\n";
print "I'll be looking for classes you might have used device drivers in ";
print "and for some of them I'll be typedef\'ining to a standard name. ";
print "This allows compiling certain applications without changing the ";
print "user/application code.\n\n";


if (-e "$yarp_root/conf/licence.short.template")
{
	# copies the licence file first.
	copy ("$yarp_root/conf/licence.short.template", "$yarp_root/src/libYARP_robot/include/yarp/YARPRobotHardware.h");
	open CONFIG, ">> $yarp_root/src/libYARP_robot/include/yarp/YARPRobotHardware.h" or die "Can't open $yarp_root/src/libYARP_robot/include/yarp/YARPRobotHardware.h";
}
else
{
	open CONFIG, "> $yarp_root/src/libYARP_robot/include/yarp/YARPRobotHardware.h" or die "Can't open $yarp_root/src/libYARP_robot/include/yarp/YARPRobotHardware.h";
}

print CONFIG "$nline$nline";
print CONFIG "/// Automatically generated by <configure.pl>$nline";
print CONFIG "#ifndef __YARPRobotHardwareh__\n#define __YARPRobotHardwareh__$nline$nline";
print CONFIG "#include <yarp/YARPConfig.h>$nline";
print CONFIG "#include <ace/config.h>$nline";
print CONFIG "#include <yarp/YARPConfigRobot.h>$nline";
print CONFIG "$nline";

chdir "$yarp_root/src/libYARP_dev" or die "Can't change to $yarp_root/src/libYARP_dev where I should find the device drivers $!\n";

foreach my $device (glob "*")
{
	if (-d "$device/$os/yarp" && $options{"Compile_Dev<-DD_$device"} eq "YES")
	{
		print "Looking for device \"$device\" in architecture \"$robotname\"\n";

		if (!open FILE, "$device/driver.conf")
		{ 
			warn "Can't open $device/driver.conf\n";
			next;
		}

		my %info;
		while (<FILE>)
		{
			chomp;
			if (/(\bYARP(\w+)\b) +(\bYARP\w+\b)/)
			{
				$info{$2} = "$1 $3";
			}
		}
		
		close FILE;

		if (scalar(@keys = keys %info) == 0)
		{
			print "Nothing known about the use of $device, skipping it...\n";
			next;
		}

		while (my ($key, $value) = each (%info))
		{
			my $mnemo = $key;
			$value =~ /^(\w+) (\w+)$/;
			my $app_class_name = $1;
			my $gen_class_name = $2;

			my $best_match = '';
			my $filename = '';
			my $params_class_name = '';

			($best_match, 
			 $filename, 
			 $params_class_name) = 
				mysearch_inheaders ($mnemo, $app_class_name, $gen_class_name, $robotname, $device);

			if ($best_match ne '')
			{
				my $answer = '';
				print "My best algorithm suggests the following addition:\n\n";
				print "#include <yarp/$filename.h>\n";
				print "#ifndef $app_class_name\n";
				print "#define $app_class_name $best_match\n";
				print "#endif\n";
				print "#ifndef $app_class_name"."Params\n";
				print "#define $app_class_name"."Params $params_class_name\n";
				print "#endif\n\n\n";

				print "Confirm addition to YARPRobotHardware.h, type SKIP to skip this definition or NO to enter a new one [YES]? ";
				chomp ($answer = <STDIN>);
				if ($answer eq '' || $answer =~ /\b[Yy1]\w*/)
				{
					print CONFIG "/// #define for device driver \"$device\" in context \"$robotname\"$nline";
					print CONFIG "#include <yarp/$filename.h>$nline";
					print CONFIG "#ifndef $app_class_name$nline";
					print CONFIG "#define $app_class_name $best_match$nline";
					print CONFIG "#endif$nline";
					print CONFIG "#ifndef $app_class_name"."Params$nline";
					print CONFIG "#define $app_class_name"."Params $params_class_name$nline";
					print CONFIG "#endif$nline$nline$nline";
				}
				elsif ($answer eq "SKIP")
				{
					print CONFIG "/// skipped device driver \"$device\" in context \"$robotname\"$nline$nline";
				}
				else
				{
					print "Ok, you didn't like my suggestion, type your own then, I'll close my eyes :)";
					print "[Enter class name e.g. YARPYourArchitectureYourDeviceDriver] ";
					chomp ($answer = <STDIN>);
					if (answer ne '')
					{
						print CONFIG "/// #define for device driver $device in context $robotname$nline";

						# additional include file.
						print "Please, tell me also what file to include [something like yarp/FILE.h: type the filename and the .h!]\n";
						my $ans2 = '';
						chomp ($ans2 = <STDIN>);
						if ($ans2 ne '')
						{
							print CONFIG "#include <yarp/$ans2>$nline";
						}

						print CONFIG "#ifndef $app_class_name$nline";
						print CONFIG "#define $app_class_name $answer$nline";
						print CONFIG "#endif$nline";
						print CONFIG "#ifndef $app_class_name"."Params$nline";
						print CONFIG "#define $app_class_name"."Params $answer"."Params$nline";
						print CONFIG "#endif$nline$nline$nline";

						print "Added:\n\n";
						print "#include <yarp/$ans2>\n";
						print "#ifndef $app_class_name\n";
						print "#define $app_class_name $answer\n";
						print "#endif\n";
						print "#ifndef $app_class_name"."Params\n";
						print "#define $app_class_name"."Params $answer"."Params\n";
						print "#endif\n\n\n";
					}
					else
					{
						print "Nothing added to this configuration for device \"$device\"\n";
					}
				}
			}
			else
			{
				print "Can't find anything appropriate for \"$device\"\n";
			}

		} # end while ()
	}
}

chdir "$cur_dir" or die "Can't change back to my home dir: $cur_dir $!\n";

print CONFIG "#endif$nline";
close CONFIG;

print "\nI've created $yarp_root/src/libYARP_robot/include/yarp/YARPRobotHardware.h which is ";
print "needed by certain applications. It contains #defines for the robot components you might ";
print "likely use often.\n\n";

print "We're done for now, the context file has been updated: \"$config_file\"\n";
print "A new project reflecting your choices has been created in \"./src\"\n";
print "Type \"build.pl\" later to start the build process\n\n";

print "I'm going to create a new project file for \"$robotname\"\n";

if ($os eq "winnt")
{
	create_project_dsp();
}
elsif ($os eq "linux")
{
	create_project_generic();
}
elsif ($os eq "qnx6")
{
	create_project_generic();
}

#
# creating a new config file.
# 
save_config_file (\%options, $config_file);

print "Done!\n";


#
#
#
sub create_project_generic
{
	#
	# create the local Makefile first.

        open MODEL, "Makefile.model" or die "Can't open model Makefile: $!\n";
        open PROJECT, ">Makefile" or die "Can't open destination project Makefile: $!\n";

        while (<MODEL>)
        {
                if (/SUBDIRS =/)
                {
                        print PROJECT "SUBDIRS = $robotname/yarp src\n";
                }
                else
                {
                        print PROJECT $_;
                }
        }

        close MODEL;
        close PROJECT;

	#
	# then create the src Makefile.

        open MODEL, "./src/Makefile.model" or die "Can't open model src/Makefile: $!\n";
        open PROJECT, ">./src/Makefile" or die "Can't open destination project src/Makefile: $!\n";

        while (<MODEL>)
        {
                if (/TARGETS \+=/)
                {
                        print PROJECT "TARGETS += ";

			foreach my $filename (glob "$robotname/yarp/*.cpp")
                        {
				if ($filename =~ /(YARP[\w\s_]+.)cpp/)
				{
					print PROJECT "../obj/$os/$1o ";
				}
                        }
                        
                        print PROJECT "\n";
                }
                else
                {
                        print PROJECT $_;
                }
        }

        close MODEL;
        close PROJECT;

	0;
}


#
#
#
sub create_project_dsp
{
	open PROJECT, "./src/libYARP_robot.dsp" or die "Can't open project file: $!\n";
	$newname = "libYARP_robot_$robotname";
	open MYPROJECT, "> ./src/$newname.dsp" or die "Can't open output project file: $!\n";

	while (<PROJECT>)
	{
		s/libYARP_robot/$newname/g;
		if (/# Begin Group "robots"/)
		{
			print MYPROJECT $_;
			print MYPROJECT "\r\n# PROP Default_Filter \"\"\r\n";
			print MYPROJECT "# Begin Group \"$robotname\"\r\n\r\n";
			print MYPROJECT "# PROP Default_Filter \"h;cpp\"\r\n";
			last;
		}
		elsif (/# Begin Group "Header Files"/)
		{
			print MYPROJECT $_;
			while (<PROJECT>)
			{
				s/libYARP_robot/$newname/g;
				if (/# Begin Source File/)
				{
					# add the new file.
					print MYPROJECT "$_\r\n";
					if (-e "./include/yarp/YARPRobotHardware.h")
					{
						print MYPROJECT "SOURCE=..\\include\\yarp\\YARPRobotHardware.h\r\n";
						print MYPROJECT "# End Source File\r\n";
						print MYPROJECT "# Begin Source File\r\n";
						last;
					}
				}			
			}
		}
		else
		{
			print MYPROJECT $_;
		}
	}

	foreach my $file (glob "$robotname/yarp/*.cpp $robotname/yarp/*.h")
	{
		print MYPROJECT "# Begin Source File\r\n\r\n";
		$file =~ s#/#\\#g;
		my $line = "SOURCE=..\\$file\r\n";
		print MYPROJECT "$line";
		print MYPROJECT "# End Source File\r\n";
	}

	print MYPROJECT "# End Group\r\n";
	print MYPROJECT "# End Group\r\n";
	print MYPROJECT "# End Target\r\n# End Project\r\n";

	close MYPROJECT;
	close PROJECT;

	0;
}


#
#
#
sub mysearch_inheaders
{
	my ($mnemo, $app_class_name, $gen_class_name, $robotname, $device) = @_;
	my %searchfor = ("001" => "YARP\u\L$robotname\E$mnemo");
	my $best_match = "999";
	my $filename = '';
	my $params_class_name = '';

	foreach my $file (glob "$cur_dir/$robotname/yarp/*.h")
	{
		if (!open FILE, "$file")
		{ 
			warn "Can't open $file: $!\n";
			next;
		}

		my @matching_lines = grep {/\b\s+$gen_class_name/} <FILE>;
		
		if (@matching_lines != ())
		{
			print "\nFound for device \"$device\" ", scalar @matching_lines, " instance(s) of \"$gen_class_name\":\n";
			print @matching_lines;
			print "\n\n";

			foreach my $line (@matching_lines)
			{
				while (($key, $value) = each %searchfor)
				{
					print "Looking in \@matching_lines for : $value \n";
					if ($line =~ /\b$value/)
					{
						print "Found match of type $key: $& \n";
						if ($key lt $best_match)
						{ 
							$best_match = $key;
							if ($file =~ <\/?\w+\.h>)
							{
								$filename = $&;
							}

							print "Looking for other classes\n";
							if ($line =~ /<YARP\w+,\s+(YARP\w+)>/)
							{
								# it could be also matched for Params termination.
								$params_class_name = $1;
							}
						}
					}
				}
			}
		}

		close FILE;
	}

	($searchfor{$best_match}, $filename, $params_class_name);
}
