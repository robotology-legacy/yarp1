#! /usr/bin/perl
#
#	--file <config_file>
#		where <config_file> is the filename of the context config file.
#

use Getopt::Long;
use File::Copy;
use Cwd;

print "Entering configure process of YARP hardware support...\n";
print "This is possibly the most intricate piece of configuration in YARP.\n\n";

chomp ($ver = `ver`);
chomp ($uname = `uname`);
if (index ($ver, "Windows") < 0 && index ($uname, "uname") < 0)
{
	print "This is a Windows 2000/XP specific script\n";
	print "Perhaps this procedure can be simply extended to\n"; 
	print "other OSes but for now, this is all experimental...\n";
	
	die "This script is specific to Windows 2000/XP and Cygwin\n";
}

$yarp_root = $ENV{'YARP_ROOT'};
if (!defined($yarp_root))
{
	die "YARP_ROOT environment variable must be defined!\nto point to the path of the yarp source distribution\n";
}

print "\nReady to start...\n";

my $config_file = "$yarp_root/conf/context.conf";
my %options = ();

GetOptions ('file=s' => \$config_file );

if (-e $config_file)
{
	copy ($config_file, "$config_file.old");

	open CONFIG, $config_file or die "Can't open config file $!";

	my $contextual;
	while (<CONFIG>)
	{
		chomp;
		if (/^\[(\w+)\]$/)
		{
			$contextual = $1;
		}
		elsif (/^([A-Za-z0-9_]+)= ?/)
		{
			$options{$contextual."<-".$1} = $';
		}
	}

	close CONFIG;
}

#
#
#
my $os = $options{"Architecture<-OS"};
my $robotname = $options{"Architecture<-Hardware_Name"};
my $cur_dir = getcwd;

#
#
#
print "Now I'm going to ask a few questions that I need for configuring the device drivers.\n";
print "Your \$YARP_ROOT is: \"$yarp_root\"\n\n";
print "Please, use always the forward slash as a separator when indicating pathnames!\n";

print "I determined already that you're running on Windows. ";
die "But, your config file doesn't report so\n" unless ($os eq "winnt");

print "I also imagine you've compiled YARP_OS, YARP_sig, YARP_dev, YARP_math, I'm not checking for it so please ";
print "make sure you've run \"configure.pl\" and \"build.pl\" for YARP_OS, YARP_sig, YARP_dev, and YARP_math.\n\n";

print "You are going to provide information on your hardware configuration here. ";
print "If this procedure isn't clear to you, please, have a look at the documentation.\n";
print "Once more you are on a \"$os\" machine and configuring for something called \"$robotname\"\n\n";

print "These are the standard flags for compiling the library:\n";

get_option_hash ("Compile_Robot<-Lib_Clean", "FALSE", "Clean first: i.e. rebuild libraries?");
get_option_hash ("Compile_Robot<-Lib_Debug", "FALSE", "Compile debug version?");
get_option_hash ("Compile_Robot<-Lib_Release", "FALSE", "Compile release (optimized)?");
get_option_hash ("Compile_Robot<-Lib_Install", "FALSE", "Install after build?");

if ($options{"Compile_Robot<-Lib_Clean"} eq "TRUE" &&
	$options{"Compile_Robot<-Lib_Debug"} eq "FALSE" &&
	$options{"Compile_Robot<-Lib_Release"} eq "FALSE" &&
	$options{"Compile_Robot<-Lib_Install"} eq "TRUE")
{
	print "Asked to clean and install but not to rebuild anything, I assume debug compile\n";
	$options{"Compile_Robot<-Lib_Debug"} = "TRUE";
}

get_option_hash ("Compile_Robot<-Tools_Rebuild", "NO", "Would you like to recompile the tools?");

if ($options{"Compile_Robot<-Tools_Rebuild"} eq "NO" &&
	$options{"Compile_Robot<-Lib_Clean"} eq "TRUE")
{
	print "You're rebuilding, you need to compile the tools too. ";
	print "I'm doing it for you.\n";
	$options{"Compile_Robot<-Tools_Rebuild"} = "YES";
}

get_option_hash ("Compile_Robot<-Tools_Debug", "FALSE", "Would you like to compile the tools with debug enabled?");

print "Browsing through the list of available device drivers\n";
print "I'll be looking for classes you might have used device drivers in ";
print "and for some of them I'll be typedef\'ining to a standard name. ";
print "This allows compiling certain applications without changing the ";
print "user/application code.\n\n";


if (-e "$yarp_root/conf/licence.short.template")
{
	# copies the licence file first.
	copy ("$yarp_root/conf/licence.short.template", "$yarp_root/src/libYARP_robot/include/yarp/YARPRobotHardware.h");
	open CONFIG, ">> $yarp_root/src/libYARP_robot/include/yarp/YARPRobotHardware.h" or die "Can't open $yarp_root/src/libYARP_robot/include/yarp/YARPRobotHardware.h";
}
else
{
	open CONFIG, "> $yarp_root/src/libYARP_robot/include/yarp/YARPRobotHardware.h" or die "Can't open $yarp_root/src/libYARP_robot/include/yarp/YARPRobotHardware.h";
}

print CONFIG "\n\n";
print CONFIG "/// Automatically generated by <configure.pl>\n";
print CONFIG "#ifndef __YARPRobotHardwareh__\n#define __YARPRobotHardwareh__\n\n";
print CONFIG "#include <yarp/YARPConfig.h>\n";
print CONFIG "#include <ace/config.h>\n";
print CONFIG "#include <yarp/YARPConfigRobot.h>\n";
print CONFIG "\n";

chdir "$yarp_root/src/libYARP_dev" or die "Can't change to $yarp_root/src/libYARP_dev where I should find the device drivers $!\n";

foreach my $device (glob "*")
{
	if (-d "$device/$os/yarp")
	{
		print "Looking for device \"$device\" in architecture \"$robotname\"\n";

		if (!open FILE, "$device/driver.conf")
		{ 
			warn "Can't open $device/driver.conf\n";
			next;
		}

		my $line;
		my $app_class_name;
		my $mnemo;
		my $gen_class_name;

		chomp($line = <FILE>);
		if ($line =~ /(\bYARP(\w+)\b) +(\bYARP\w+\b)/)
		{
			$app_class_name = $1;
			$mnemo = $2;
			$gen_class_name = $3;
			close FILE;
		}
		else
		{
			close FILE;
			next;
		}

		%searchfor = ("001" => "YARP\u\L$robotname\E$mnemo");

		my $best_match = "999";
		my $filename = '';
		my $params_class_name = '';

		foreach my $file (glob "$cur_dir/$robotname/yarp/*.h")
		{
			if (!open FILE, "$file")
			{ 
				warn "Can't open $file: $!\n";
				next;
			}

			my @matching_lines = grep {/\b\s+$gen_class_name/} <FILE>;
			
			if (@matching_lines != ())
			{
				print "\nFound for device \"$device\" ", scalar @matching_lines, " instance(s) of \"$gen_class_name\":\n";
				print @matching_lines;
				print "\n\n";

				foreach my $line (@matching_lines)
				{
					while (($key, $value) = each %searchfor)
					{
						print "Looking in \@matching_lines for : $value \n";
						if ($line =~ /\b$value/)
						{
							print "Found match of type $key: $& \n";
							if ($key lt $best_match)
							{ 
								$best_match = $key;
								if ($file =~ <\/?\w+\.h>)
								{
									$filename = $&;
								}

								print "Looking for other classes\n";
								if ($line =~ /<YARP\w+,\s+(YARP\w+)>/)
								{
									# it could be also matched for Params termination.
									$params_class_name = $1;
								}
							}
						}
					}
				}
			}

			close FILE;
		}

		if ($best_match ne "999")
		{
			my $answer = '';
			print "My best algorithm suggests the following addition:\n\n";
			print "#include <yarp/$filename.h>\n";
			print "#ifndef $app_class_name\n";
			print "#define $app_class_name $searchfor{$best_match}\n";
			print "#endif\n";
			print "#ifndef $app_class_name"."Params\n";
			print "#define $app_class_name"."Params $params_class_name\n";
			print "#endif\n\n\n";

			print "Confirm addition to YARPRobotHardware.h, type SKIP to skip this definition or NO to enter a new one [YES]? ";
			chomp ($answer = <STDIN>);
			if ($answer eq '' || $answer eq "YES")
			{
				print CONFIG "/// #define for device driver \"$device\" in context \"$robotname\"\n";
				print CONFIG "#include <yarp/$filename.h>\n";
				print CONFIG "#ifndef $app_class_name\n";
				print CONFIG "#define $app_class_name $searchfor{$best_match}\n";
				print CONFIG "#endif\n";
				print CONFIG "#ifndef $app_class_name"."Params\n";
				print CONFIG "#define $app_class_name"."Params $params_class_name\n";
				print CONFIG "#endif\n\n\n";
			}
			elsif ($answer eq "SKIP")
			{
				print CONFIG "/// skipped device driver \"$device\" in context \"$robotname\"\n\n";
			}
			else
			{
				print "Ok, you didn't like my suggestion, type your own then, I'll close my eyes :)";
				print "[Enter class name e.g. YARPYourArchitectureYourDeviceDriver] ";
				chomp ($answer = <STDIN>);
				if (answer ne '')
				{
					print CONFIG "/// #define for device driver $device in context $robotname\n";

					# additional include file.
					print "Please, tell me also what file to include [something like yarp/FILE.h: type the filename and the .h!]\n";
					my $ans2 = '';
					chomp ($ans2 = <STDIN>);
					if ($ans2 ne '')
					{
						print CONFIG "#include <yarp/$ans2>\n";
					}

					print CONFIG "#ifndef $app_class_name\n";
					print CONFIG "#define $app_class_name $answer\n";
					print CONFIG "#endif\n";
					print CONFIG "#ifndef $app_class_name"."Params\n";
					print CONFIG "#define $app_class_name"."Params $answer"."Params\n";
					print CONFIG "#endif\n\n\n";

					print "Added:\n\n";
					print "#include <yarp/$ans2>\n";
					print "#ifndef $app_class_name\n";
					print "#define $app_class_name $answer\n";
					print "#endif\n";
					print "#ifndef $app_class_name"."Params\n";
					print "#define $app_class_name"."Params $answer"."Params\n";
					print "#endif\n\n\n";
				}
				else
				{
					print "Nothing added to this configuration for device \"$device\"\n";
				}
			}
		}
		else
		{
			print "Can't find anything appropriate for \"$device\"\n";
		}
	}
}

chdir "$cur_dir" or die "Can't change back to my home dir: $cur_dir $!\n";

print CONFIG "#endif\n";
close CONFIG;

print "\nI've created $yarp_root/src/libYARP_robot/include/yarp/YARPRobotHardware.h which is ";
print "needed by certain applications. It contains #defines for the robot components you might ";
print "likely use often.\n\n";

print "We're done for now, the context file has been updated: \"$config_file\"\n";
print "A new project reflecting your choices has been created in \"./src\"\n";
print "Type \"build.pl\" later to start the build process\n\n";

print "I'm going to create a new project file for \"$robotname\"\n";

#
#
#
#
open PROJECT, "./src/libYARP_robot.dsp" or die "Can't open project file: $!\n";
$newname = "libYARP_robot_$robotname";
open MYPROJECT, "> ./src/$newname.dsp" or die "Can't open output project file: $!\n";

while (<PROJECT>)
{
	s/libYARP_robot/$newname/g;
	if (/# Begin Group "robots"/)
	{
		print MYPROJECT $_;
		print MYPROJECT "\n# PROP Default_Filter \"\"\n";
		print MYPROJECT "# Begin Group \"$robotname\"\n\n";
		print MYPROJECT "# PROP Default_Filter \"cpp;h\"\n";
		last;
	}
	elsif (/# Begin Group "Header Files"/)
	{
		print MYPROJECT $_;
		while (<PROJECT>)
		{
			s/libYARP_robot/$newname/g;
			if (/# Begin Source File/)
			{
				# add the new file.
				print MYPROJECT "$_\n";
				if (-e "./include/yarp/YARPRobotHardware.h")
				{
					print MYPROJECT "SOURCE=..\\include\\yarp\\YARPRobotHardware.h\n";
					print MYPROJECT "# End Source File\n";
					print MYPROJECT "# Begin Source File\n";
					last;
				}
			}			
		}
	}
	else
	{
		print MYPROJECT $_;
	}
}

foreach my $file (glob "$robotname/yarp/*.cpp $robotname/yarp/*.h")
{
	print MYPROJECT "# Begin Source File\n\n";
	$file =~ s#/#\\#g;
	my $line = "SOURCE=..\\$file\n";
	print MYPROJECT "$line";
	print MYPROJECT "# End Source File\n";
}

print MYPROJECT "# End Group\n";
print MYPROJECT "# End Group\n";
print MYPROJECT "# End Target\n# End Project\n";

close MYPROJECT;
close PROJECT;

#
# uses global value %options
#
sub get_option_hash
{
	my ($key, $default_value, $message) = @_;
	my $line = undef;

	$options{$key} = $default_value if (!exists($options{$key}));

	print "$message [$options{$key}] ";
	chomp($line = <STDIN>);
	$options{$key} = $line if (defined($line) && $line ne '');

	0;
}


#
# creating a new config file.
# 
open CONFIG, "> $config_file";
select CONFIG;

print "//\n";
print "// This is an example of configuration file.\n";
print "// - projects and include files are created relying on this options.\n";
print "//\n";
print "// Generated by <configure.pl>\n";
print "//\n";

my $context = '';
foreach my $key (sort keys %options)
{
	my $value = $options{$key};
	$key =~ /<-/;
	if ($context ne $`)
	{
		$context = $`;
		print "\n[$context]\n";
	}
	print "$'= $value\n";
}

select STDOUT;
close CONFIG;

print "Done!\n";