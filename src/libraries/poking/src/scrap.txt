/***************************************************************************
 **** main piece of logic
 ***************************************************************************/

static int OldRingleader(YARPImageOf<YarpPixelBGR>& src, 
			 YARPImageOf<YarpPixelBGR>& dest,
			 YARPImageOf<YarpPixelMono>& dest_aux,
			 YARPImageOf<YarpPixelMono>& dest_aux_grip)
{
  static IntegralImageTool ii_tool;
  static YARPImageOf<YarpPixelFloat> response, prev_response, prev_seg,
    before, before2, before3, prev_mono, mono, prev_mono2, prev_mask2,
    prev_mono_b, before_b, work;

  static int first = 1;
  static int slowdown = 0;
  static int post_contact = 0;
  static int awaiting_contact = 1;
  static long int frame_idx = 0;
  int should_declare = 0;
  
  if (force_first) 
    {
      first = 1;
      slowdown = 0;
      frame_idx = 0;
    }
  
  float v = GetMotion(src,dest,response);

  SpotPotentialCollision(src,response,dest,0,frame_idx>=10);

  int contact = contact_declared && awaiting_contact;
  frame_idx++;
  if (contact)
    {
      awaiting_contact = 0;
    }

  mono.CastCopy(src);
  if (first)
    {
      before.PeerCopy(response);
      before_b.PeerCopy(response);
      before2.PeerCopy(response);
      before3.PeerCopy(response);
      prev_mono.PeerCopy(mono);
      prev_mono_b.PeerCopy(mono);
    }
  

  if (use_segmentation)
    {
      if (contact)
	{
	  AlignMotion(mono,prev_mono_b,before_b,before2,dest);
	  ii_tool.GetMean(before2,before3,1);
	  prev_mask2.PeerCopy(before3);
#ifdef PRETTY_OUTPUT
#ifndef PRETTY_OUTPUT2
	  YarpPixelBGR pixg(0,255,0);
	  YarpPixelBGR pixb(0,0,255);
	  for (int i=58; i<62; i++)
	    {
	      AddCircleOutline(dest,(1)?pixg:pixb,64,64,i);
	    }
	  YARPImageOf<YarpPixelBGR> dest;
	  dest = src;
#endif
#endif
	  float q = PrimarySegmentation(src,response,before3,dest,dest_aux,
					dest_aux_grip,contact);
	  slowdown = 3;
	  prev_response.PeerCopy(response);
	  prev_seg.CastCopy(dest_aux);
	}
      else if (post_contact)
	{
	  SatisfySize(mono,work);
	  int bx, by;
	  AlignMotion(mono,prev_mono,before3,before2,dest,&bx,&by);
	  global_dx_grip = bx;
	  global_dy_grip = by;
	  AlignMotion(mono,prev_mono,prev_response,work,dest,&bx,&by,0);
	  prev_response.PeerCopy(work);
	  AlignMotion(mono,prev_mono,prev_seg,work,dest,&bx,&by,0);
	  prev_seg.PeerCopy(work);
	  IMGFOR(prev_response,x,y)
	    {
	      prev_response(x,y) = maxf(prev_response(x,y),
					maxf(prev_seg(x,y),response(x,y)));
	    }
	  printf("*** POST CONTACT!\n");
	  float q = PrimarySegmentation(src,prev_response,before2,dest,
					dest_aux,dest_aux_grip,1);
	  
#ifdef PRETTY_OUTPUT2
	  YARPImageOf<YarpPixelBGR> dest;
	  dest = src;
#endif
	  slowdown = 3;
	  should_declare = (q>0.01);
	  if (should_declare)
	    {
	      q = OptimizeSegment(src,dest_aux,dest_aux,dest);
	      should_declare = (q>0.01);
	    }
	}
    }

  prev_mono_b.PeerCopy(prev_mono);
  before_b.PeerCopy(before);
  prev_mono.PeerCopy(mono);
  before.PeerCopy(response);

  first = 0;
  if (post_contact == 1) 
    {
      post_contact = 0;
      awaiting_contact = 1;
    }
  if (contact)  post_contact = 1;


  return should_declare;
}

