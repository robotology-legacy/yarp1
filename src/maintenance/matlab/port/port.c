/////////////////////////////////////////////////////////////////////////
///                                                                   ///
///                                                                   ///
/// This Academic Free License applies to any software and associated ///
/// documentation (the "Software") whose owner (the "Licensor") has   ///
/// placed the statement "Licensed under the Academic Free License    ///
/// Version 1.0" immediately after the copyright notice that applies  ///
/// to the Software.                                                  ///
/// Permission is hereby granted, free of charge, to any person       ///
/// obtaining a copy of the Software (1) to use, copy, modify, merge, ///
/// publish, perform, distribute, sublicense, and/or sell copies of   ///
/// the Software, and to permit persons to whom the Software is       ///
/// furnished to do so, and (2) under patent claims owned or          ///
/// controlled by the Licensor that are embodied in the Software as   ///
/// furnished by the Licensor, to make, use, sell and offer for sale  ///
/// the Software and derivative works thereof, subject to the         ///
/// following conditions:                                             ///
/// Redistributions of the Software in source code form must retain   ///
/// all copyright notices in the Software as furnished by the         ///
/// Licensor, this list of conditions, and the following disclaimers. ///
/// Redistributions of the Software in executable form must reproduce ///
/// all copyright notices in the Software as furnished by the         ///
/// Licensor, this list of conditions, and the following disclaimers  ///
/// in the documentation and/or other materials provided with the     ///
/// distribution.                                                     ///
///                                                                   ///
/// Neither the names of Licensor, nor the names of any contributors  ///
/// to the Software, nor any of their trademarks or service marks,    ///
/// may be used to endorse or promote products derived from this      ///
/// Software without express prior written permission of the Licensor.///
///                                                                   ///
/// DISCLAIMERS: LICENSOR WARRANTS THAT THE COPYRIGHT IN AND TO THE   ///
/// SOFTWARE IS OWNED BY THE LICENSOR OR THAT THE SOFTWARE IS         ///
/// DISTRIBUTED BY LICENSOR UNDER A VALID CURRENT LICENSE. EXCEPT AS  ///
/// EXPRESSLY STATED IN THE IMMEDIATELY PRECEDING SENTENCE, THE       ///
/// SOFTWARE IS PROVIDED BY THE LICENSOR, CONTRIBUTORS AND COPYRIGHT  ///
/// OWNERS "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, ///
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   ///
/// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO      ///
/// EVENT SHALL THE LICENSOR, CONTRIBUTORS OR COPYRIGHT OWNERS BE     ///
/// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN   ///
/// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN ///
/// CONNECTION WITH THE SOFTWARE.                                     ///
///                                                                   ///
/// This license is Copyright (C) 2002 Lawrence E. Rosen. All rights  ///
/// reserved. Permission is hereby granted to copy and distribute     ///
/// this license without modification. This license may not be        ///
/// modified without the express written permission of its copyright  ///
/// owner.                                                            ///
///                                                                   ///
///                                                                   ///
/////////////////////////////////////////////////////////////////////////

///
///
///       YARP - Yet Another Robotic Platform (c) 2001-2003 
///
///                    #pasa#
///
///     "Licensed under the Academic Free License Version 1.0"
///

///
/// $Id: port.c,v 1.2 2003-11-18 00:30:18 gmetta Exp $
///
///

/* $Revision: 1.2 $ */
// Automatically generated by MATLAB Project Wizard version 1.0

//
// This is the gateway routine for a MATLAB Math/Graphics Library-based
// C MATLAB MEX File.

#include "mex.h"

#include "global.h"
#include <string.h>

/*
struct _paramsTag
{
	char *_portname;		/// symbolic name of the port.
	enum _dataType _type;	/// type of the port.
	char *_protocol;		/// protocol TCP/UDP/MCAST...
	bool _direction;		/// true means INPUT port, false means OUTPUT port
	char *_network;			/// name of the subnetwork, otherwise default.
	int _extra_params;		/// buffering, multiple output specs.
	int _portnumber;		/// if the entry is known, identifies the port uniquely.
};
*/

///
///
#define __DEBUG_MESSAGES 1

/// checks whether it's a string (just one string).
int isString (const mxArray *ar)
{
	if (mxIsChar(ar) != 1 || 
		mxGetNumberOfDimensions(ar) != 2 || 
		mxGetM(ar) != 1)
		return 0;
	else
		return 1;
}

enum _dataType stringToEnum (const char *s)
{
	if (strncmp(s, "int", 3) == 0)
		return MX_YARP_INT;
	else
	if (strncmp(s, "double", 6) == 0)
		return MX_YARP_DOUBLE;
	else
	if (strncmp(s, "vector", 6) == 0)
		return MX_YARP_YVECTOR;
	else
	if (strncmp(s, "image", 5) == 0)
		return MX_YARP_IMAGE;
	else
		return MX_YARP_INVALID;
}

///
///
/// just a check for scalar double type.
bool isScalarDouble (const mxArray *a)
{
	if (!mxIsDouble(a) || mxIsComplex(a) || mxGetNumberOfDimensions(a) != 2)
		return false;
	else
		return true;
}

///
///
/// fill out the params struct.
int fillParams (char *operation, int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[], _dispatchParams *params)
{
	char *temp = NULL;

	if (strncmp(operation, "create", 6) == 0)
	{
		if (nlhs > 1) 
			mexErrMsgTxt("Too many output arguments.\n");

		if (nrhs <= 3 || nrhs > 4)
			mexErrMsgTxt("Incorrect number of arguments.\n");

		/// param 1, port type.
		if (!isString(prhs[1])) 
			mexErrMsgTxt("Input argument 1 is not a string.\n");
		params->_portname = NULL;
		temp = mxCalloc(mxGetN(prhs[1]) + 1, sizeof(char));
		mxGetString(prhs[1], temp, mxGetN(prhs[1]) + 1);
		params->_type = stringToEnum(temp);
		
		/// param 3, protocol type (TCP, UDP, MCAST, etc.).
		if (nrhs == 4)
		{
			if (!isString(prhs[3]))
				mexErrMsgTxt("Input argument 3 must be a string.\n");
			params->_protocol = mxCalloc(mxGetN(prhs[3]) + 1, sizeof(char));
			mxGetString(prhs[3], params->_protocol, mxGetN(prhs[3]) + 1);
		}
		else
		{
			params->_protocol = mxCalloc(4, sizeof(char));
			strncpy (params->_protocol, "tcp", 3);
			params->_protocol[3] = 0;
		}

		/// param 2, direction IN/OUT.
		if (!isScalarDouble(prhs[2]))
			mexErrMsgTxt("Input argument 2 is not a double.\n");
			
		params->_direction = (mxGetScalar(prhs[2]) != 0.0) ? false : true;
		params->_network = NULL;
		params->_extra_params = 0;
		params->_portnumber = 0;
		params->_extra_content = NULL;
		params->_sizex = 0;
		params->_sizey = 0;

#ifdef __DEBUG_MESSAGES
		mexPrintf ("creating an %s port of type %s and protocol %s\n", 
			(params->_direction)?"input":"output",
			temp,
			params->_protocol);
#endif

	}
	else
	if (strncmp(operation, "register", 8) == 0)
	{
		if (nlhs > 1) 
			mexErrMsgTxt("Too many output arguments.\n");

		if (nrhs != 4)
			mexErrMsgTxt("Incorrect number of arguments.\n");

		/// param 2, port name (to register).
		if (!isString(prhs[2])) 
			mexErrMsgTxt("Input argument 2 is not a string.\n");
		params->_portname = mxCalloc(mxGetN(prhs[2]) + 1, sizeof(char));
		mxGetString(prhs[2], params->_portname, mxGetN(prhs[2]) + 1);

		params->_type = MX_YARP_INVALID;
		params->_protocol = NULL;
		params->_direction = false;

		/// param 3, network name.
		if (!isString(prhs[3])) 
			mexErrMsgTxt("Input argument 3 is not a string.\n");
		params->_network = mxCalloc(mxGetN(prhs[3]) + 1, sizeof(char));
		mxGetString(prhs[3], params->_network, mxGetN(prhs[3]) + 1);
			
		params->_extra_params = 0;

		/// param 1, the port number (a small integer ID).
		if (!isScalarDouble(prhs[1]))
			mexErrMsgTxt("Input argument 1 is not a scalar.\n");
			
		params->_portnumber = (int)(mxGetScalar(prhs[1])+.5);
		params->_extra_content = NULL;
		params->_sizex = 0;
		params->_sizey = 0;

#ifdef __DEBUG_MESSAGES
		mexPrintf ("registering entry %d to name %s on network %s\n", 
			params->_portnumber,
			params->_portname,
			params->_network);
#endif

	}
	else
	if (strncmp(operation, "unregister", 10) == 0)
	{
		if (nlhs > 1) 
			mexErrMsgTxt("Too many output arguments.\n");

		if (nrhs != 2)
			mexErrMsgTxt("Incorrect number of arguments.\n");

		params->_portname = NULL;
		params->_type = MX_YARP_INVALID;
		params->_protocol = NULL;
		params->_direction = false;
		params->_network = NULL;
		params->_extra_params = 0;

		/// param 1, the port number (a small integer ID).
		if (!isScalarDouble(prhs[1]))
			mexErrMsgTxt("Input argument 1 is not a scalar.\n");
			
		params->_portnumber = (int)(mxGetScalar(prhs[1])+.5);
		params->_extra_content = NULL;
		params->_sizex = 0;
		params->_sizey = 0;

#ifdef __DEBUG_MESSAGES
		mexPrintf ("unregistering entry %d\n", params->_portnumber);
#endif

	}
	else
	if (strncmp(operation, "destroy", 7) == 0)
	{
		if (nlhs > 1) 
			mexErrMsgTxt("Too many output arguments.\n");

		if (nrhs != 2)
			mexErrMsgTxt("Incorrect number of arguments.\n");

		params->_portname = NULL;
		params->_type = MX_YARP_INVALID;
		params->_protocol = NULL;
		params->_direction = false;
		params->_network = NULL;
		params->_extra_params = 0;

		/// param 1, the port number (a small integer ID).
		if (!isScalarDouble(prhs[1]))
			mexErrMsgTxt("Input argument 1 is not a scalar.\n");
			
		params->_portnumber = (int)(mxGetScalar(prhs[1])+.5);
		params->_extra_content = NULL;
		params->_sizex = 0;
		params->_sizey = 0;

#ifdef __DEBUG_MESSAGES
		mexPrintf ("destroying entry %d\n", params->_portnumber);
#endif

	}
	else
	if (strncmp(operation, "list", 4) == 0)
	{
		if (nlhs > 1) 
			mexErrMsgTxt("Too many output arguments.\n");

		if (nrhs != 1)
			mexErrMsgTxt("Incorrect number of arguments.\n");

		params->_portname = NULL;
		params->_type = MX_YARP_INVALID;
		params->_protocol = NULL;
		params->_direction = false;
		params->_network = NULL;
		params->_extra_params = 0;
		params->_portnumber = 0;
		params->_extra_content = mxCalloc (4096, sizeof(char));
		params->_sizex = 0;
		params->_sizey = 0;
	}
	else
	if (strncmp(operation, "read", 4) == 0)
	{
		/// returning two params (the ans and the read value).
		if (nlhs > 2)
			mexErrMsgTxt("Too many output arguments.\n");

		if (nrhs > 3)
			mexErrMsgTxt("Incorrect number of arguments.\n");

		params->_portname = NULL;
		params->_type = MX_YARP_INVALID;
		params->_protocol = NULL;
		params->_direction = false;
		params->_network = NULL;

		if (nrhs == 3)
		{
			/// param 2, blocking/non blocking read.
			if (!isScalarDouble(prhs[2]))
				mexErrMsgTxt("Input argument 2 is not a scalar.\n");
			
			params->_extra_params = (int)(mxGetScalar(prhs[2])+.5);
		}
		else
			params->_extra_params = 1;

		/// param 1, the port number (a small integer ID).
		if (!isScalarDouble(prhs[1]))
			mexErrMsgTxt("Input argument 1 is not a scalar.\n");
			
		params->_portnumber = (int)(mxGetScalar(prhs[1])+.5);

		/// this represents the return value(s).
		params->_extra_content = NULL;
		params->_sizex = 0;
		params->_sizey = 0;

#ifdef __DEBUG_MESSAGES
		mexPrintf ("reading from entry %d\n", params->_portnumber);
#endif
	}
	else
	if (strncmp(operation, "write", 5) == 0)
	{
		if (nlhs > 1)
			mexErrMsgTxt("Too many output arguments.\n");

		if (nrhs > 4 || nrhs < 3)
			mexErrMsgTxt("Incorrect number of arguments.\n");

		params->_portname = NULL;
		params->_type = MX_YARP_INVALID;
		params->_protocol = NULL;
		params->_direction = false;
		params->_network = NULL;

		if (nrhs == 4)
		{
			/// param 3, blocking/non blocking write.
			if (!isScalarDouble(prhs[3]))
				mexErrMsgTxt("Input argument 3 is not a scalar.\n");
			
			params->_extra_params = (int)(mxGetScalar(prhs[3])+.5);
		}
		else
			params->_extra_params = 0;

		/// param 1, the port number (a small integer ID).
		if (!isScalarDouble(prhs[1]))
		{
			mexErrMsgTxt("Input argument 1 is not a scalar.\n");
		}
		
		params->_portnumber = (int)(mxGetScalar(prhs[1])+.5);

		/// data to be written in parameter 2.
		/// it can be anything...
		if (mxGetNumberOfDimensions(prhs[2]) != 2)
			mexErrMsgTxt("Input argument 2 is not a vector\n");

		params->_extra_content = (char *)mxGetPr(prhs[2]);
		params->_sizex = mxGetN(prhs[2]);	/// columns.
		params->_sizey = mxGetM(prhs[2]);	/// rows.

#ifdef __DEBUG_MESSAGES
		mexPrintf ("writing to entry %d\n", params->_portnumber);
#endif
	}
	else
	if (strncmp(operation, "porter", 6) == 0)
	{
		if (nlhs > 1)
			mexErrMsgTxt("Too many output arguments.\n");

		if (nrhs != 3)
			mexErrMsgTxt("Incorrect number of arguments.\n");

		/// param 1, port name (first arg to porter).
		if (!isString(prhs[1])) 
			mexErrMsgTxt("Input argument 1 is not a string.\n");
		params->_portname = mxCalloc(mxGetN(prhs[1]) + 1, sizeof(char));
		mxGetString(prhs[1], params->_portname, mxGetN(prhs[1]) + 1);

		params->_type = MX_YARP_INVALID;
		params->_protocol = NULL;
		params->_direction = false;
		params->_network = NULL;
		params->_extra_params = 0;
		params->_portnumber = -1;

		/// param 2, second argument to porter.
		if (!isString(prhs[2])) 
			mexErrMsgTxt("Input argument 2 is not a string.\n");
		params->_extra_content = mxCalloc(mxGetN(prhs[2]) + 1, sizeof(char));
		mxGetString(prhs[2], params->_extra_content, mxGetN(prhs[2]) + 1);

		params->_sizex = 0;
		params->_sizey = 0;

#ifdef __DEBUG_MESSAGES
		mexPrintf ("porter from %s to %s\n", params->_portname, params->_extra_content);
#endif
	}
	else
		return -1;

	return 0;
}

///
///
///
void post_dispatcher (char *operation, _dispatchParams *params)
{
	if (strncmp(operation, "list", 4) == 0)
	{
		if (params->_extra_content != NULL)
			mexPrintf ("%s", params->_extra_content);
	}
}

void freeParams (char *operation, _dispatchParams *params)
{
	if (params != NULL)
	{
		if (params->_portname != NULL) mxFree(params->_portname);
		if (params->_protocol != NULL) mxFree(params->_protocol);
		if (params->_network != NULL) mxFree(params->_network);

		/// for read do not clear mem since it's just a pointer to the port's content.
		if (strncmp(operation, "read", 4) != 0 && strncmp(operation, "write", 5) != 0)
		{
			if (params->_extra_content != NULL) mxFree(params->_extra_content);
		}

		mxFree(params);
	}
}

void fillOutput (char *operation, int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[], _dispatchParams *params, int return_value)
{
	if (return_value < 0)
	{
		plhs[0] = mxCreateScalarDouble(return_value);
		prhs[1] = mxCreateScalarDouble(0);
	}
	else
	if (strncmp(operation, "read", 4) == 0)
	{
		switch (params->_type)
		{
		case MX_YARP_INT:
			plhs[0] = mxCreateScalarDouble((double)(*(int *)params->_extra_content));
			if (nlhs == 2)
			{
				plhs[1] = mxCreateScalarDouble(return_value);
			}
			break;

		case MX_YARP_DOUBLE:
			plhs[0] = mxCreateScalarDouble((double)(*(double *)params->_extra_content));
			if (nlhs == 2)
			{
				plhs[1] = mxCreateScalarDouble(return_value);
			}
			break;

		case MX_YARP_FLOAT:
			plhs[0] = mxCreateScalarDouble((double)(*(float *)params->_extra_content));
			if (nlhs == 2)
			{
				plhs[1] = mxCreateScalarDouble(return_value);
			}
			break;

		default:
			mexPrintf ("troubles, shouldn't be executing this\n");
			prhs[0] = mxCreateScalarDouble(-1);
			prhs[1] = mxCreateScalarDouble(0);
			break;
		}
	}
	else
	{
		plhs[0] = mxCreateScalarDouble(return_value);
		prhs[1] = mxCreateScalarDouble(0);
	}
}

///
///	EXAMPLES:
///		p = port('create', 'int', 0);							/// creates an out port of type int.
///		ans = port('register', p, '/matlab/test', 'default');	/// registers port <p> into the name server.
///		ans = port('unregister', p);							/// unregisters port <p> from the name server.
///		ans = port('destroy', p);								/// calls the port destructor.
///		ans = port('list');										/// lists the ports in the internal structure.
///		[ans, datum] = port('read', p, wait);					/// reads from port <p> and return data in <datum>, <wait> optional flag blocking/non.
///		ans = port('write', p, datum);							/// writes to port <p> data in <datum>.
///

///
///
/// MEX function entry point.
///
void mexFunction(
	int nlhs,              // Number of left hand side (output) arguments
	mxArray *plhs[],       // Array of left hand side arguments
	int nrhs,              // Number of right hand side (input) arguments
	const mxArray *prhs[]  // Array of right hand side arguments
)
{
	/// <1> is a string containing the name of the operation on port (e.g. create, destroy, etc).
	/// <2> a list of various things.
	///
	///		create: type of data, direction
	///			returns a small integer to identify the port later on, -1 on failure.
	///		register: port name, network name
	///			returns -1 on failure.
	///		unregister: none
	///			returns -1 on failure.
	///		destroy: none
	///			returns -1 on failure.
	///		list: none
	///			prints the internal list of ports.
	///		read: port entry, and blocking flag
	///			returns the data read from the port and the failure code (2 params).
	///		write: port entry and data to write
	///			returns -1 on failure.
	///

	char *operation = NULL;
	_dispatchParams *params = NULL;
	int buflen = 0;
	int return_value = -1;

	if (nrhs < 1)
		mexErrMsgTxt("Not enough input parameters to do anything.\n");

	if (mxIsChar(prhs[0]) != 1 || mxGetNumberOfDimensions(prhs[0]) != 2 || mxGetM(prhs[0]) != 1)
		mexErrMsgTxt("1st parameter must be a string.\n");
    
	buflen = mxGetN(prhs[0]) + 1;
	operation = mxCalloc(buflen, sizeof(char));
	mxGetString(prhs[0], operation, buflen);

	params = mxCalloc(1, sizeof(_dispatchParams));

	/// since I now know the operation, I can try reading the params.
	return_value = fillParams (operation, nlhs, plhs, nrhs, prhs, params);
	if (return_value < 0)
		mexErrMsgTxt("one parameter is wrong, can't call dispatcher function.\n");

	/// call the C++ dispatcher.
	return_value = dispatcher (operation, (void *)params);

	/// call a post processing routine, to complete any unfinished business.
	post_dispatcher (operation, params);

	/// fills the output arrays (and alloc them appropriately.
	fillOutput (operation, nlhs, plhs, nrhs, prhs, params, return_value);

	/// free memory before leaving.
	freeParams (operation, params);

	mxFree (operation);

	return;
}


