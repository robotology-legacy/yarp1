
/* still needs some fixing for the "no connections" case */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>


#define MAXNODES 24
#define MAXPORTS 4

#define MINNET 0
#define MAXNET 127


struct port {
  int dest;
  int dst_port;
  int net;
};


struct node {
  int number;
  struct port port[MAXPORTS]; /* = # of connected node */
  char *drivername;
};


struct node *find_or_insert_node(int num, struct node *list)
{
  int i;
  
  for (i=0; (i < MAXNODES) && (list[i].number != 0) ; i++) {
    if (list[i].number == num)
      return &(list[i]);
  }
  if (i < MAXNODES) {
    list[i].number = num;
    return &(list[i]);
  }
  return NULL;
}
 


void gen_netscript(FILE *fp, struct node *node)
{
  int n, p;
  struct node *ni;

  fprintf(fp, "#!/bin/sh\n");
  fprintf(fp, "\n");
  fprintf(fp, "# Point-to-point network setup script\n");
  fprintf(fp, "# \n");
  fprintf(fp, "# This script was automagically generated.\n");
  fprintf(fp, "# If you modify it by hand you will eventually "
	  "lose your changes.\n");
  fprintf(fp, "\n\n");

  /* helper function to load netmaps */
  fprintf(fp, "# wait until remote node's net is up, then grab netmap\n");
  fprintf(fp, "#   $1=node  $2=net\n");
  fprintf(fp, "grab_netmap()\n");
  fprintf(fp, "{\n");
  fprintf(fp, "  until netinfo -n$1 -L$2 > /dev/null ; do\n");
  fprintf(fp, "    sleep 1\n");
  fprintf(fp, "  done\n");
  fprintf(fp, "  netmap -n$1 | netmap -F -\n");
  fprintf(fp, "}\n");
  fprintf(fp, "\n");
  fprintf(fp, "\n");

  fprintf(fp, "echo Setting up point-to-point network...\n");
  fprintf(fp, "\n");

  for (n = 0; (n < MAXNODES) && (node[n].number != 0); n++) {
    ni = &(node[n]);
    fprintf(fp, "# Node %d\n", ni->number);
    fprintf(fp, "if [ $NODE -eq %d ]; then   \n", ni->number);
    /* start drivers */
    for (p = 0; p < MAXPORTS; p++) {
      if (ni->port[p].dest != 0) {
	fprintf(fp, "   %s -r101000000 -I%d -l%d &\n",
		ni->drivername, p, ni->port[p].net);
      }
    }
    /* wait a sec */
    fprintf(fp, "   sleep 1\n");
    /* run netmap */
    for (p = 0; p < MAXPORTS; p++) {
      if (ni->port[p].dest != 0) {
	fprintf(fp, "   grab_netmap %d %d\n", 
		ni->port[p].dest, ni->port[p].net);
      }
    }
    fprintf(fp, "fi\n");
  }
  fprintf(fp, "\n");

#if 0
  for (n = 0; (n < MAXNODES) && (node[n].number != 0); n++) {
    ni = &(node[n]);
    fprintf(fp, "# Node %d\n", ni->number);
    fprintf(fp, "if [ $NODE == %d ]; then   \n", ni->number);
    for (p = 0; p < MAXPORTS; p++) {
      if (ni->port[p].dest != 0) {
	fprintf(fp, "   grab_netmap %d %d\n", 
		ni->port[p].dest, ni->port[p].net);
      }
    }
    fprintf(fp, "fi\n");
  }
#endif
    fprintf(fp, "\n");
    fprintf(fp, "\n");
    fprintf(fp, "\n");
}



struct node node[MAXNODES];

int verbose = 1;

void parse_freenet(char *line, int *free_net)
{
  if (*free_net != 0) {
    fprintf(stderr, "freenet specified twice!\n");
    exit(1);
  }
  sscanf(line, "%d\n", free_net);
  if (verbose) fprintf(stderr, "freenet: %d\n", *free_net);
  
  if ((*free_net < MINNET) || (*free_net > MAXNET)) {
    fprintf(stderr, "freenet %d out of range [%d,%d]!\n",
	    *free_net, MINNET, MAXNET);
    exit(1);
  }
}


void parse_driver(char *line, struct node *node)
{
  int num;
  char driver[128];
  struct node *si;

  sscanf(line, "%d  %s\n", &num, driver);
  if (verbose) fprintf(stderr, "driver: %d ''%s''\n", num, driver);

  si = find_or_insert_node(num, node);
  if (si == NULL) {
    fprintf(stderr, "Too many nodes!\n");
    exit(1);
  }
  if (si->drivername != NULL) {
    fprintf(stderr, "Driver for %d specified twice!\n", num);
    fprintf(stderr, "%s", line);
    exit(1);
  }
  si->drivername = strdup(driver); /* FIX THIS */
}


void parse_connect(char *line, int *free_net, struct node *node)
{
  int sn,sp,dn,dp;
  struct node *si, *di;

  if (*free_net == 0) {
    fprintf(stderr, "freenet must be specified before connections!\n");
    exit(1);
  }
  sscanf(line, "%d . %d , %d . %d\n", &sn, &sp, &dn, &dp);
  if (verbose) fprintf(stderr, "connect: %d.%d <-> %d.%d", sn, sp, dn, dp);
  
  if ((sp < 0) || (sp > MAXPORTS - 1) ||
      (dp < 0) || (dp > MAXPORTS - 1)) {
    fprintf(stderr, "\nPort out of range\n");
    exit(1);
  }
  
  si = find_or_insert_node(sn, node);
  di = find_or_insert_node(dn, node);
  if ((si == NULL) || (di == NULL)) {
    fprintf(stderr, "\nToo many nodes!\n");
    exit(1);
  }
  
  if ((si->port[sp].dest != 0) &&
      ((si->port[sp].dest != dn) || (si->port[sp].dst_port != dp))) {
    fprintf(stderr, "\nOops!  %d.%d used twice!\n", sn, sp);
    exit(1);
  }
  if ((di->port[dp].dest != 0) &&
      ((di->port[dp].dest != sn) || (di->port[dp].dst_port != sp))) {
    fprintf(stderr, "\nOops!  %d.%d used twice!\n", dn, dp);
    exit(1);
  }
  
  if ((si->port[sp].dest == 0) || (di->port[dp].dest == 0)) {
    if (*free_net > MAXNET) {
      fprintf(stderr, 
	      "\nToo many connections:  logical net %d too big!\n",
	      *free_net);
      exit(1);
    }
    si->port[sp].dest = dn;
    si->port[sp].dst_port = dp;
    si->port[sp].net = *free_net;
    di->port[dp].dest = sn;
    di->port[dp].dst_port = sp;
    di->port[dp].net = *free_net;
    (*free_net)++;
  } else {
    if (verbose) fprintf(stderr, " (duplicate)");
  }
  if (verbose) fprintf(stderr, "\n");
} 



void usage_and_exit(char *name)
{
  fprintf(stderr, "Usage:  %s config-file [output-file]\n", name);
  fprintf(stderr, "\n");
  fprintf(stderr, "Reads config-file and generates a setup script for\n");
  fprintf(stderr, " multiport point-to-point network connection.\n");
  fprintf(stderr, "If output filename is not specified, it defaults\n");
  fprintf(stderr, " to stdout.\n");
}



int main(int argc, char *argv[])
{
  int free_net = 0;
  char line[128];
  int i;
  FILE *fin, *fout;

  if ((argc < 2) || (argc > 3)) usage_and_exit(argv[0]);

  /* get arguments (input and output filenames) */
  if ((fin = fopen(argv[1], "r")) == NULL) {
    fprintf(stderr, "Could not open config file %s.\n", argv[1]);
    exit(1);
  }
  if (argc == 3) {
    if ((fout = fopen(argv[2], "w")) == NULL) {
      fprintf(stderr, "Could not open output file %s.\n", argv[2]);
      exit(1);
    }
  } else {
    fout = stdout;
  }
      
  
  /* parse configuration file */
  while (fgets(line, 128, fin) != NULL) {
    if (line[0] == '#') continue;
    if (!(strncmp("freenet", line, 7))) {
      parse_freenet(line+7, &free_net);
      continue;
    }
    if (!(strncmp("driver", line, 6))) {
      parse_driver(line+6, node);
      continue;
    }
    if (!(strncmp("connect", line, 7))) {
      parse_connect(line+7, &free_net, node);
      continue;
    }
  }

  /* check for drivers */
  for (i=0; (i < MAXNODES) && (node[i].number != 0) ; i++) {
    if (node[i].drivername == NULL) {
      fprintf(stderr, "No driver named for node %d!\n", node[i].number);
      exit(1);
    }
  }

  /* ok, go generate script */
  gen_netscript(fout, node);

  exit(0);
}



