

meid v2:  MEI Motor Controller Driver
-------------------------------------------------------------------------

(c)2000 Matt Marjanovic, The Cog Shop, MIT AI Lab
        <maddog@ai.mit.edu>

-------------------------------------------------------------------------


meid is an interface to the MEI's library for its motion controller cards.
This is version 2, which is significantly different on the driver/daemon
 side, but mostly the same from the client-side API.

Why do this?
 o The MEI Library requires port access; now, the driver can be compiled
    with "-T 1" and run as root, while user programs can be just that,
    plain old user programs.
 o The meid driver can take better care of some startup/shutdown operations,
    and keep a better eye on access control.
 o An MEI card and an application driving it can now reside on different
    nodes (and choke the network with motor commands).

How is v2 different from v1?
 o Implemented as I/O Manager, vs. vanilla message server.
 o Overhauled function dispatching (more efficient, lower overhead).
 o Much more stringent adherence to simple design as a translator for 
    the MEI library:
      - removed composite "calibration" functions
      - cleaned up function prototypes
 o Easier to add new functions.


Compiling and Installing
------------------------

Type "make" in the top-level directory to compile it all.
Type "make install" to install the components under /home/cog/.

Installed components:
  /home/cog/lib/meid.lib
  /home/cog/include/meid.h
  /home/cog/sbin/meid



Running the Driver
------------------

Run "meid -b 0xNNN &" as root, on whatever node the card is installed.
 The driver will create a character special file on the node, named
 "/dev/mei0xNNN", for the device.  The client library opens the device
 read/write, to send commands to it; only one process at a time is
 allowed to do this (because resource sharing/allocation should be
 handled carefully by *that* process).  However, multiple processes
 can open the device read-only --- the only reason this is useful is
 that a simple read from the device (i.e. "cat /dev/mei0xNNN") will
 give out status information about the driver/card.

Command line arguments:
  -b 0xNNN   -- set base address of the card (default: 0x320).
  -p pri     -- set priority of driver
  -V N       -- set verbosity level, for debugging (default: 0).

Interrupts are not enabled/handled.  I'm not even sure what the MEI Lib
 can do with them --- probably not a good sign for the MEI Lib!

Be careful not to run two meid's trying to access the same card/base-address.
 They will probably collide hopelessly.



The Client-side
---------------

Essentially, every MEI Library function has an equivalent function in
 the meid library; the function name is prefixed with "meid_" and one
 int16 argument ("meidx") is prepended to the argument list.  This means
 that any software written to use the straight-up MEI Library can be
 easily converted to use meid.

Furthermore, the global error code variable "meid_error" serves the
 same purpose as "dsp_error".  Some additional meid-specific error
 codes are defined in <meid.h>.

Before using any other meid function, "meid_open()" must be called
 to get the "meidx" used in all other meid functions; this is the 
 equivalent of "dsp_init()", although the usage is very different.

meid_open() takes the name of the card/device as its single paramenter;
 this is a filename, and may include a "//n" node specifier.  The return
 value is a file descriptor (int).  If an error occurs, it returns -1,
 and the standard system error code is available in "errno".

Only *one* process at a time can open the device for motor control,
 because it should be the job of that process to do resource arbitration.
 If an mei device is already open for control (i.e. via meid_open()),
 then any other attempt to open it will fail with an EBUSY error.
(Note that if a process forks, than its child will properly inherit
 the file descriptor, and thus two processes could simultaneously
 command the driver.)

When finished using a card, the descriptor should be closed by calling
 "meid_close()".  If a program dies mysteriously or otherwise, the OS
 will automatically close the file descriptor.


Some functions are NOT implemented in the meid client library, and should
 not be:  dsp_init, download_firmware, upload_firmware, error_msg, ...
Blocking/waiting functions such as move() and wait_done() might be
 hopeless, since the MEI library itself is lame and does this with
 simple polling.  (It might be possible to rig interrupts to do 
 this the right way....)  In any case, blocking functions should
 *never* be called within the driver itself.

Many functions are "not yet" implemented in the meid client library;
 that would have been a lot of grunge work.  You can add new functions
 pretty easily.  Read "README.new_functions".



