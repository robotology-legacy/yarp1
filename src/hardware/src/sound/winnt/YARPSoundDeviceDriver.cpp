// =====================================================================================
//
//       YARP - Yet Another Robotic Platform (c) 2001-2003 
//
//                    #Ing. Carlos Beltran#
//
//     "Licensed under the Academic Free License Version 1.0"
// 
//        Filename:  YARPSoundDeviceDriver.cpp
// 
//     Description:  
// 
//         Version:  $Id: YARPSoundDeviceDriver.cpp,v 1.8 2004-03-01 18:01:00 beltran Exp $
// 
//          Author:  Ing. Carlos Beltran (Carlos), cbeltran@dist.unige.it
//         Company:  Lira-Lab
// 
// =====================================================================================

#define _WINDOWS

#include "YARPSoundResources.h"
#include <YARPSoundCardUtils.h>

// ===  FUNCTION  ======================================================================
// 
//         Name: RES  
// 
//  Description: This is a convenient function to recover the pointer to the SoundResources
//  object  
// 
//    Author:  Ing. Carlos Beltran
//  Revision:  none
// =====================================================================================
inline SoundResources& RES(void *res) { return *(SoundResources *)res; }

//--------------------------------------------------------------------------------------
//       Class:  YARPSoundDeviceDriver
//      Method:  (Constructor) YARSoundDeviceDriver
// Description:  Initializes and sets the IOCtl functions mapping
//--------------------------------------------------------------------------------------
YARPSoundDeviceDriver::YARPSoundDeviceDriver(void) : 
YARPDeviceDriver<YARPNullSemaphore, YARPSoundDeviceDriver>(SCMDNCmds)
{
	system_resources = (void *) new SoundResources;
	ACE_ASSERT (system_resources != NULL);

	/// for the IOCtl call. Here the mapping for the IOCtl should be included
	m_cmds[SCMDAcquireBuffer] = &YARPSoundDeviceDriver::acquireBuffer;
	m_cmds[SCMDReleaseBuffer] = &YARPSoundDeviceDriver::releaseBuffer;
	m_cmds[SCMDWaitNewFrame]  = &YARPSoundDeviceDriver::waitOnNewFrame;
	m_cmds[SCMDSetMute]       = &YARPSoundDeviceDriver::set_mute;
	m_cmds[SCMDSetVolume]     = &YARPSoundDeviceDriver::set_volume;
}

//--------------------------------------------------------------------------------------
//       Class:  YARPSoundDeviceDriver
//      Method:  ~YARPSoundDeviceDriver 
// Description:  (Destructor)
//--------------------------------------------------------------------------------------
YARPSoundDeviceDriver::~YARPSoundDeviceDriver()
{
	if (system_resources != NULL)
		delete (SoundResources *)system_resources;
	system_resources = NULL;
}

//--------------------------------------------------------------------------------------
//       Class:  YARPSoundDeviceDriver
//      Method:  open 
// Description:  (public) this is one of the external visible method. It supports the 
// abstraction (open,close,IOCtl). 
//--------------------------------------------------------------------------------------
int 
YARPSoundDeviceDriver::open (void *res)
{
	int ret;
	SoundResources& d = RES(system_resources);
	
	//Start the thread first. The identifier is necesary in the lower level	
	Begin ();  //Will see if this is necessary (probably it is) the thread id is latter used
	/*
	 * The thread ID is necesary to run the waveIn call that uses it to assing
	 * the callback message to this thread. Therefore, the Body part of the
	 * thread will receive the messages (linked internally to hardware
	 * interrupts) generated by the low level sound driver. 
	 */
	((SoundOpenParameters *)res)->m_callbackthread_identifier = this->identifier;
	
	ret = d._initialize (*(SoundOpenParameters *)res);

	return ret;
}

//--------------------------------------------------------------------------------------
//       Class:  YARPSoundDeviceDriver
//      Method:  close
// Description:  (public) This is the close of the abstraction (open, close, IOCtl..)
//--------------------------------------------------------------------------------------
int 
YARPSoundDeviceDriver::close (void)
{
	SoundResources& d = RES(system_resources);

	End (); //This ends the thread. Will see if is really necessary in the sound driver	

	int ret = d._uninitialize ();

	return ret;
}

//--------------------------------------------------------------------------------------
//       Class:  YARPSoundDeviceDriver
//      Method:  Body()
// Description:  Here, the body of the thread should be implemented
//--------------------------------------------------------------------------------------
void 
YARPSoundDeviceDriver::Body (void)
{
	SoundResources& d = RES(system_resources);
	MSG		msg;

	const int prio = ACE_Sched_Params::next_priority (ACE_SCHED_OTHER, GetPriority(), ACE_SCOPE_THREAD);
	SetPriority (prio);
	
	// Wait for a message sent by the audio driver
	while (GetMessage(&msg, 0, 0, 0) == 1 && !IsTerminated()) {

		switch (msg.message) {
			case MM_WIM_DATA: //Buffer filled 
				////printf("yarpsounddriver: received data\n");
				// msg.lParam contains a pointer to the WAVEHDR structure for the filled buffer.
				if (((WAVEHDR *)msg.lParam)->dwBytesRecorded) {
					//Here write in the local buffer using the syncronization mutexes
					/*
					   if (!WriteFile(WaveFileHandle, ((WAVEHDR *)msg.lParam)->lpData, ((WAVEHDR *)msg.lParam)->dwBytesRecorded, &msg.time, 0) ||
					   msg.time != ((WAVEHDR *)msg.lParam)->dwBytesRecorded)
					   {
					   }
					   */
					if (d._bmutex.PollingWait () == 1) {
						/// buffer acquired. Reading from the buffer
						memcpy (d._rawBuffer, 
								((WAVEHDR *)msg.lParam)->lpData, 
								((WAVEHDR *)msg.lParam)->dwBytesRecorded); 
						//Note: is this right? The buffer could not be full...

						if (d._canpost) {
							d._canpost = false;
							d._new_frame.Post();
						}
						d._bmutex.Post ();
					}
					else
					{
						/// can't acquire, it means the buffer is still in use.
						/// silently ignores this condition.
						ACE_DEBUG ((LM_DEBUG, "lost a frame, acq thread\n"));
					}
				}

				//Requeue the used buffer	
				waveInAddBuffer(d.m_WaveInHandle, (WAVEHDR *)msg.lParam, sizeof(WAVEHDR));

				break;
				/* Our main thread is opening the WAVE device */
			case MM_WIM_OPEN:
				ACE_DEBUG ((LM_DEBUG, "yarpsounddriver: sound device opened\n"));
				break;
				/* Our main thread is closing the WAVE device */
			case MM_WIM_CLOSE:
				break;
			default:
				//ACE_DEBUG ((LM_DEBUG, "yarpsounddriver: received an unknown message\n"));
				break;
		}
	}

	ACE_DEBUG ((LM_DEBUG, "acquisition thread returning...\n"));
}

//--------------------------------------------------------------------------------------
//       Class:  YARPSoundDeviceDriver
//      Method:  acquireBuffer
// Description:  This method blocks the access to the lockable buffer. This allows to
// obtain access to a clear copy without DMA interferences
//--------------------------------------------------------------------------------------
int 
YARPSoundDeviceDriver::acquireBuffer (void *buffer)
{
	SoundResources& d = RES(system_resources);
	d._bmutex.Wait ();
	(*(unsigned char **)buffer) = d._rawBuffer;

	return YARP_OK;
}

//--------------------------------------------------------------------------------------
//       Class:  YARPSoundDeviceDriver
//      Method:  releaseBuffer
// Description:  This method release the mutex controlling the exclusive access to the 
// buffer containing the data, thus the thread can write in the common buffer getting the
// data from the memory used by the DMA.
//--------------------------------------------------------------------------------------
int
YARPSoundDeviceDriver::releaseBuffer (void *cmd)
{
	SoundResources& d = RES(system_resources);
	d._canpost = true;
	d._bmutex.Post ();

	return YARP_OK;
}

//--------------------------------------------------------------------------------------
//       Class:  YARSoundDeviceDriver
//      Method:  waitOnNewFrame
// Description:  This call blocks until new data is available in the common buffer
//--------------------------------------------------------------------------------------
int 
YARPSoundDeviceDriver::waitOnNewFrame (void *cmd)
{
	SoundResources& d = RES(system_resources);
	d._new_frame.Wait ();

	return YARP_OK;
}

//--------------------------------------------------------------------------------------
//       Class:  YARPSoundDeviceDriver
//      Method:  set_mute
// Description:  This function set the mute state in the already selected line.
// Use:
// 	0 -> mute
// 	1 -> No mute
//--------------------------------------------------------------------------------------
int 
YARPSoundDeviceDriver::set_mute(void *cmd)
{
	MIXERCONTROLDETAILS_UNSIGNED	value[2];
	MIXERCONTROLDETAILS				mixerControlDetails;
	MMRESULT						err;
	
	SoundResources& d = RES(system_resources);

	unsigned int * m_mute_state = (unsigned int *) cmd;
	//
	// Select the mute control in the selected line
	// 
	d._select_control(MIXERCONTROL_CONTROLTYPE_MUTE);
	
	mixerControlDetails.cbStruct = sizeof(MIXERCONTROLDETAILS);
	mixerControlDetails.dwControlID = d.m_mixerControlArray.dwControlID;
	mixerControlDetails.cChannels = d.m_mixerLine.cChannels;
	
	if (mixerControlDetails.cChannels > 2) mixerControlDetails.cChannels = 2;
	
	if (d.m_mixerControlArray.fdwControl & MIXERCONTROL_CONTROLF_UNIFORM) mixerControlDetails.cChannels = 1;

	mixerControlDetails.cMultipleItems = 0;
	mixerControlDetails.paDetails = &value[0];
	mixerControlDetails.cbDetails = sizeof(MIXERCONTROLDETAILS_UNSIGNED);
	value[0].dwValue = value[1].dwValue = (*m_mute_state);

	err = mixerSetControlDetails((HMIXEROBJ)d.m_MixerHandle, 
								 &mixerControlDetails, 
								 MIXER_SETCONTROLDETAILSF_VALUE);
	
	if( err != MMSYSERR_NOERROR) printf("yarpsounddriver: Error #%d setting mute for %s!\n", err, d.m_mixerLine.szName);

	return YARP_OK;
}

//--------------------------------------------------------------------------------------
//       Class:  YARPSoundDeviceDriver
//      Method:  set_volume
// Description:  This function set the volume in both channels
//--------------------------------------------------------------------------------------
int 
YARPSoundDeviceDriver::set_volume(void *cmd)
{
	MIXERCONTROLDETAILS_UNSIGNED	value[2];
	MIXERCONTROLDETAILS				mixerControlDetails;
	MMRESULT						err;
	
	SoundResources& d = RES(system_resources);

	unsigned int * m_volume = (unsigned int *) cmd;

	/*
	 * Select the control type in the current line
	 */
	d._select_control(MIXERCONTROL_CONTROLTYPE_VOLUME);
	
	mixerControlDetails.cbStruct = sizeof(MIXERCONTROLDETAILS);
	mixerControlDetails.dwControlID = d.m_mixerControlArray.dwControlID;
	mixerControlDetails.cChannels = 2;
	mixerControlDetails.cMultipleItems = 0;
	mixerControlDetails.paDetails = &value[0];
	mixerControlDetails.cbDetails = sizeof(MIXERCONTROLDETAILS_UNSIGNED);
	value[0].dwValue = value[1].dwValue = (*m_volume);

	err = mixerSetControlDetails((HMIXEROBJ)d.m_MixerHandle, 
								 &mixerControlDetails, 
								 MIXER_SETCONTROLDETAILSF_VALUE);
	
	if( err != MMSYSERR_NOERROR) printf("yarpsounddriver: Error #%d setting mute for %s!\n", err, d.m_mixerLine.szName);
	
	return YARP_OK;
}

#undef _WINDOWS
