/////////////////////////////////////////////////////////////////////////
///                                                                   ///
///                                                                   ///
/// This Academic Free License applies to any software and associated ///
/// documentation (the "Software") whose owner (the "Licensor") has   ///
/// placed the statement "Licensed under the Academic Free License    ///
/// Version 1.0" immediately after the copyright notice that applies  ///
/// to the Software.                                                  ///
/// Permission is hereby granted, free of charge, to any person       ///
/// obtaining a copy of the Software (1) to use, copy, modify, merge, ///
/// publish, perform, distribute, sublicense, and/or sell copies of   ///
/// the Software, and to permit persons to whom the Software is       ///
/// furnished to do so, and (2) under patent claims owned or          ///
/// controlled by the Licensor that are embodied in the Software as   ///
/// furnished by the Licensor, to make, use, sell and offer for sale  ///
/// the Software and derivative works thereof, subject to the         ///
/// following conditions:                                             ///
/// Redistributions of the Software in source code form must retain   ///
/// all copyright notices in the Software as furnished by the         ///
/// Licensor, this list of conditions, and the following disclaimers. ///
/// Redistributions of the Software in executable form must reproduce ///
/// all copyright notices in the Software as furnished by the         ///
/// Licensor, this list of conditions, and the following disclaimers  ///
/// in the documentation and/or other materials provided with the     ///
/// distribution.                                                     ///
///                                                                   ///
/// Neither the names of Licensor, nor the names of any contributors  ///
/// to the Software, nor any of their trademarks or service marks,    ///
/// may be used to endorse or promote products derived from this      ///
/// Software without express prior written permission of the Licensor.///
///                                                                   ///
/// DISCLAIMERS: LICENSOR WARRANTS THAT THE COPYRIGHT IN AND TO THE   ///
/// SOFTWARE IS OWNED BY THE LICENSOR OR THAT THE SOFTWARE IS         ///
/// DISTRIBUTED BY LICENSOR UNDER A VALID CURRENT LICENSE. EXCEPT AS  ///
/// EXPRESSLY STATED IN THE IMMEDIATELY PRECEDING SENTENCE, THE       ///
/// SOFTWARE IS PROVIDED BY THE LICENSOR, CONTRIBUTORS AND COPYRIGHT  ///
/// OWNERS "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, ///
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   ///
/// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO      ///
/// EVENT SHALL THE LICENSOR, CONTRIBUTORS OR COPYRIGHT OWNERS BE     ///
/// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN   ///
/// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN ///
/// CONNECTION WITH THE SOFTWARE.                                     ///
///                                                                   ///
/// This license is Copyright (C) 2002 Lawrence E. Rosen. All rights  ///
/// reserved. Permission is hereby granted to copy and distribute     ///
/// this license without modification. This license may not be        ///
/// modified without the express written permission of its copyright  ///
/// owner.                                                            ///
///                                                                   ///
///                                                                   ///
/////////////////////////////////////////////////////////////////////////

///
///
///       YARP - Yet Another Robotic Platform (c) 2001-2003 
///
///                    #pasa#
///
///     "Licensed under the Academic Free License Version 1.0"
///

///
/// $Id: port.c,v 1.2 2004-09-07 15:28:52 babybot Exp $
///
///

/* $Revision: 1.2 $ */
// Automatically generated by MATLAB Project Wizard version 1.0

//
// This is the gateway routine for a MATLAB Math/Graphics Library-based
// C MATLAB MEX File.

#include "mex.h"

#include "global.h"
#include <string.h>

/*
struct _paramsTag
{
	char *_portname;		/// symbolic name of the port.
	enum _dataType _type;	/// type of the port.
	char *_protocol;		/// protocol TCP/UDP/MCAST...
	bool _direction;		/// true means INPUT port, false means OUTPUT port
	char *_network;			/// name of the subnetwork, otherwise default.
	int _extra_params;		/// buffering, multiple output specs.
	int _portnumber;		/// if the entry is known, identifies the port uniquely.
};
*/

char *cell_to_bottle (mxArray* cell, int *len, char **id);
int cell_in_bytes (mxArray* cell);
char * array_to_image (mxArray* img, int* sizex, int* sizey, int* type);


///
///
#define __DEBUG_MESSAGES 1

/// checks whether it's a string (just one string).
int isString (const mxArray *ar)
{
	if (mxIsChar(ar) != 1 || 
		mxGetNumberOfDimensions(ar) != 2 || 
		mxGetM(ar) != 1)
		return 0;
	else
		return 1;
}

enum _dataType stringToEnum (const char *s)
{
	if (strncmp(s, "int", 3) == 0)
		return MX_YARP_INT;
	else
	if (strncmp(s, "double", 6) == 0)
		return MX_YARP_DOUBLE;
	else
	if (strncmp(s, "vector", 6) == 0)
		return MX_YARP_YVECTOR;
	else
	if (strncmp(s, "image", 5) == 0)
		return MX_YARP_IMAGE;
	else
	if (strncmp(s, "bottle", 6) == 0)
		return MX_YARP_BOTTLE;
	else
		return MX_YARP_INVALID;
}

///
///
/// just a check for scalar double type.
bool isScalarDouble (const mxArray *a)
{
	if (!mxIsDouble(a) || mxIsComplex(a) || mxGetNumberOfDimensions(a) != 2)
		return false;
	else
		return true;
}

///
///
/// fill out the params struct.
int fillParams (char *operation, int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[], _dispatchParams *params)
{
	char *temp = NULL;
	int itmp = 0;
	
	if (strncmp(operation, "create", 6) == 0)
	{
		mexPrintf("Parsing %d parameters\n", nrhs);
		if (nlhs > 1) 
			mexErrMsgTxt("Too many output arguments.\n");

		if (nrhs <= 3 || nrhs > 5)
			mexErrMsgTxt("Incorrect number of arguments.\n");

		/// param 1, port type.
		if (!isString(prhs[1])) 
			mexErrMsgTxt("Input argument 1 is not a string.\n");
		params->_portname = NULL;
		temp = mxCalloc(mxGetN(prhs[1]) + 1, sizeof(char));
		mxGetString(prhs[1], temp, mxGetN(prhs[1]) + 1);
		params->_type = stringToEnum(temp);
		
		/// param 3, protocol type (TCP, UDP, MCAST, etc.).
		if (nrhs == 4)
		{
			if (!isString(prhs[3]))
				mexErrMsgTxt("Input argument 3 must be a string.\n");
			params->_protocol = mxCalloc(mxGetN(prhs[3]) + 1, sizeof(char));
			mxGetString(prhs[3], params->_protocol, mxGetN(prhs[3]) + 1);
		}
		else
		{
			params->_protocol = mxCalloc(4, sizeof(char));
			strncpy (params->_protocol, "tcp", 3);
			params->_protocol[3] = 0;
		}

		/// param 2, direction IN/OUT.
		if (!isScalarDouble(prhs[2]))
			mexErrMsgTxt("Input argument 2 is not a double.\n");
			
		params->_direction = (mxGetScalar(prhs[2]) != 0.0) ? false : true;

		if(nrhs == 4)
		{
			// we have 4 parameters only
			params->_extra_content = mxCalloc(8, sizeof(char));
			sprintf(params->_extra_content, "%s", "default");
		}
		else if (nrhs == 5)
		{
			// we have 5 params
			params->_extra_content = mxCalloc(mxGetN(prhs[4]) + 1, sizeof(char));
			mxGetString(prhs[4], params->_extra_content, mxGetN(prhs[4]) + 1);
		}
		
		params->_portnumber = 0;
		params->_network = NULL;
		params->_sizex = 0;
		params->_sizey = 0;

#ifdef __DEBUG_MESSAGES
		mexPrintf ("Creating an %s port of type %s and protocol %s (%s)\n", 
			(params->_direction)?"input":"output",
			temp,
			params->_protocol,
			params->_extra_content);
#endif

	}
	else
	if (strncmp(operation, "register", 8) == 0)
	{
		if (nlhs > 1) 
			mexErrMsgTxt("Too many output arguments.\n");

		if (nrhs != 4)
			mexErrMsgTxt("Incorrect number of arguments.\n");

		/// param 2, port name (to register).
		if (!isString(prhs[2])) 
			mexErrMsgTxt("Input argument 2 is not a string.\n");
		params->_portname = mxCalloc(mxGetN(prhs[2]) + 1, sizeof(char));
		mxGetString(prhs[2], params->_portname, mxGetN(prhs[2]) + 1);

		params->_type = MX_YARP_INVALID;
		params->_protocol = NULL;
		params->_direction = false;

		/// param 3, network name.
		if (!isString(prhs[3])) 
			mexErrMsgTxt("Input argument 3 is not a string.\n");
		params->_network = mxCalloc(mxGetN(prhs[3]) + 1, sizeof(char));
		mxGetString(prhs[3], params->_network, mxGetN(prhs[3]) + 1);
			
		params->_extra_params = 0;

		/// param 1, the port number (a small integer ID).
		if (!isScalarDouble(prhs[1]))
			mexErrMsgTxt("Input argument 1 is not a scalar.\n");
			
		params->_portnumber = (int)(mxGetScalar(prhs[1])+.5);
		params->_extra_content = NULL;
		params->_sizex = 0;
		params->_sizey = 0;

#ifdef __DEBUG_MESSAGES
		mexPrintf ("registering entry %d to name %s on network %s\n", 
			params->_portnumber,
			params->_portname,
			params->_network);
#endif

	}
	else
	if (strncmp(operation, "unregister", 10) == 0)
	{
		if (nlhs > 1) 
			mexErrMsgTxt("Too many output arguments.\n");

		if (nrhs != 2)
			mexErrMsgTxt("Incorrect number of arguments.\n");

		params->_portname = NULL;
		params->_type = MX_YARP_INVALID;
		params->_protocol = NULL;
		params->_direction = false;
		params->_network = NULL;
		params->_extra_params = 0;

		/// param 1, the port number (a small integer ID).
		if (!isScalarDouble(prhs[1]))
			mexErrMsgTxt("Input argument 1 is not a scalar.\n");
			
		params->_portnumber = (int)(mxGetScalar(prhs[1])+.5);
		params->_extra_content = NULL;
		params->_sizex = 0;
		params->_sizey = 0;

#ifdef __DEBUG_MESSAGES
		mexPrintf ("unregistering entry %d\n", params->_portnumber);
#endif

	}
	else
	if (strncmp(operation, "destroy", 7) == 0)
	{
		if (nlhs > 1) 
			mexErrMsgTxt("Too many output arguments.\n");

		if (nrhs != 2)
			mexErrMsgTxt("Incorrect number of arguments.\n");

		params->_portname = NULL;
		params->_type = MX_YARP_INVALID;
		params->_protocol = NULL;
		params->_direction = false;
		params->_network = NULL;
		params->_extra_params = 0;

		/// param 1, the port number (a small integer ID).
		if (!isScalarDouble(prhs[1]))
			mexErrMsgTxt("Input argument 1 is not a scalar.\n");
			
		params->_portnumber = (int)(mxGetScalar(prhs[1])+.5);
		params->_extra_content = NULL;
		params->_sizex = 0;
		params->_sizey = 0;

#ifdef __DEBUG_MESSAGES
		mexPrintf ("destroying entry %d\n", params->_portnumber);
#endif

	}
	else
	if (strncmp(operation, "list", 4) == 0)
	{
		if (nlhs > 1) 
			mexErrMsgTxt("Too many output arguments.\n");

		if (nrhs != 1)
			mexErrMsgTxt("Incorrect number of arguments.\n");

		params->_portname = NULL;
		params->_type = MX_YARP_INVALID;
		params->_protocol = NULL;
		params->_direction = false;
		params->_network = NULL;
		params->_extra_params = 0;
		params->_portnumber = 0;
		params->_extra_content = mxCalloc (4096, sizeof(char));
		params->_sizex = 0;
		params->_sizey = 0;
	}
	else
	if (strncmp(operation, "read", 4) == 0)
	{
		/// returning two params (the ans and the read value).
		if (nlhs > 2)
			mexErrMsgTxt("Too many output arguments.\n");

		if (nrhs > 3)
			mexErrMsgTxt("Incorrect number of arguments.\n");

		params->_portname = NULL;
		params->_type = MX_YARP_INVALID;
		params->_protocol = NULL;
		params->_direction = false;
		params->_network = NULL;

		if (nrhs == 3)
		{
			/// param 2, blocking/non blocking read.
			if (!isScalarDouble(prhs[2]))
				mexErrMsgTxt("Input argument 2 is not a scalar.\n");
			
			params->_extra_params = (int)(mxGetScalar(prhs[2])+.5);
		}
		else
			params->_extra_params = 1;

		/// param 1, the port number (a small integer ID).
		if (!isScalarDouble(prhs[1]))
			mexErrMsgTxt("Input argument 1 is not a scalar.\n");
			
		params->_portnumber = (int)(mxGetScalar(prhs[1])+.5);

		/// this represents the return value(s).
		params->_extra_content = NULL;
		params->_sizex = 0;
		params->_sizey = 0;

#ifdef __DEBUG_MESSAGES
		///mexPrintf ("reading from entry %d\n", params->_portnumber);
#endif
	}
	else
	if (strncmp(operation, "write", 5) == 0)
	{
		if (nlhs > 1)
			mexErrMsgTxt("Too many output arguments.\n");

		if (nrhs > 4 || nrhs < 3)
			mexErrMsgTxt("Incorrect number of arguments.\n");

		params->_portname = NULL;
		params->_type = MX_YARP_INVALID;
		params->_protocol = NULL;
		params->_direction = false;
		params->_network = NULL;

		if (nrhs == 4)
		{
			/// param 3, blocking/non blocking write.
			if (!isScalarDouble(prhs[3]))
				mexErrMsgTxt("Input argument 3 is not a scalar.\n");
			
			params->_extra_params = (int)(mxGetScalar(prhs[3])+.5);
		}
		else
			params->_extra_params = 0;

		/// param 1, the port number (a small integer ID).
		if (!isScalarDouble(prhs[1]))
		{
			mexErrMsgTxt("Input argument 1 is not a scalar.\n");
		}
		
		params->_portnumber = (int)(mxGetScalar(prhs[1])+.5);

		/// data to be written in parameter 2.
		/// it can be anything...
		if (mxGetClassID (prhs[2]) == mxDOUBLE_CLASS || mxGetClassID (prhs[2]) == mxCHAR_CLASS)
		{
			if (mxGetNumberOfDimensions(prhs[2]) != 2)
				mexErrMsgTxt("Input argument 2 is not a vector\n");

			params->_extra_content = (char *)mxGetPr(prhs[2]);
			params->_sizex = mxGetN(prhs[2]);	/// columns.
			params->_sizey = mxGetM(prhs[2]);	/// rows.
		}
		else
		if (mxGetClassID (prhs[2]) == mxCELL_CLASS)
		{
			if (mxGetNumberOfDimensions(prhs[2]) != 2)
				mexErrMsgTxt("Input argument 2 is not a vector\n");

			///
			/// the Matlab cell is interpreted as a YARPBottle.

			/// returns the len in bytes of the string (representing the YARPBottle content).
			/// sets also the _portname to the string of the bottle ID.
			/// WARNING: bottle numbers are all converted to DOUBLE.
			///	LATER: re-implement the bottle by specifying also the type for each field.
			///		Matlab latest version supports all different types (INT, etc.).
			params->_extra_content = cell_to_bottle ((mxArray *)prhs[2], &params->_sizex, &params->_portname);
			params->_sizey = 1;	/// rows.
		}
		else
		if (mxGetClassID (prhs[2]) == mxUINT8_CLASS ||
			mxGetClassID (prhs[2]) == mxINT8_CLASS ||
			mxGetClassID (prhs[2]) == mxINT32_CLASS ||
			mxGetClassID (prhs[2]) == mxSINGLE_CLASS)
		{
			///
			/// this types are sent through a YARPGenericImage port.
			/// padding should be send trough the 16MSbits of the _extra_params field.
			///	in reality it's only computed by the conversion function on the C++ side.
			params->_extra_content = mxGetData(prhs[2]);
			itmp = mxGetNumberOfDimensions (prhs[2]);
			if (itmp == 2)
			{
				params->_sizex = mxGetN(prhs[2]);
				if (mxGetClassID(prhs[2]) == mxUINT8_CLASS)
					params->_extra_params |= ((YARP_PIXEL_MONO << 8) & 0x0000ff00);
				else
				if (mxGetClassID(prhs[2]) == mxINT8_CLASS)
					params->_extra_params |= ((YARP_PIXEL_MONO_SIGNED << 8) & 0x0000ff00);
				else
				if (mxGetClassID(prhs[2]) == mxINT32_CLASS)
					params->_extra_params |= ((YARP_PIXEL_INT << 8) & 0x0000ff00);
				else
				if (mxGetClassID(prhs[2]) == mxSINGLE_CLASS)
					params->_extra_params |= ((YARP_PIXEL_MONO_FLOAT << 8) & 0x0000ff00);
				else
					params->_extra_params |= ((YARP_PIXEL_INVALID << 8) & 0x0000ff00);
			}
			else
			if (itmp == 3)
			{
				params->_sizex = mxGetN(prhs[2]) / 3;
				if (mxGetClassID(prhs[2]) == mxUINT8_CLASS)
					params->_extra_params |= ((YARP_PIXEL_RGB << 8) & 0x0000ff00);
				else
				if (mxGetClassID(prhs[2]) == mxINT8_CLASS)
					params->_extra_params |= ((YARP_PIXEL_RGB_SIGNED << 8) & 0x0000ff00);
				else
				if (mxGetClassID(prhs[2]) == mxINT32_CLASS)
					params->_extra_params |= ((YARP_PIXEL_INVALID << 8) & 0x0000ff00);
				else
				if (mxGetClassID(prhs[2]) == mxSINGLE_CLASS)
					params->_extra_params |= ((YARP_PIXEL_RGB_FLOAT << 8) & 0x0000ff00);
				else
					params->_extra_params |= ((YARP_PIXEL_INVALID << 8) & 0x0000ff00);
			}
			else
				mexErrMsgTxt("The input image is of an unknown type and size\n");

			params->_sizey = mxGetM(prhs[2]);
		}
		else
		{
			mexErrMsgTxt("Write cannot handle the data type provided\n");
		}

#ifdef __DEBUG_MESSAGES
		///mexPrintf ("writing to entry %d\n", params->_portnumber);
#endif
	}
	else
	if (strncmp(operation, "porter", 6) == 0)
	{
		if (nlhs > 1)
			mexErrMsgTxt("Too many output arguments.\n");

		if (nrhs != 3)
			mexErrMsgTxt("Incorrect number of arguments.\n");

		/// param 1, port name (first arg to porter).
		if (!isString(prhs[1])) 
			mexErrMsgTxt("Input argument 1 is not a string.\n");
		params->_portname = mxCalloc(mxGetN(prhs[1]) + 1, sizeof(char));
		mxGetString(prhs[1], params->_portname, mxGetN(prhs[1]) + 1);

		params->_type = MX_YARP_INVALID;
		params->_protocol = NULL;
		params->_direction = false;
		params->_network = NULL;
		params->_extra_params = 0;
		params->_portnumber = -1;

		/// param 2, second argument to porter.
		if (!isString(prhs[2])) 
			mexErrMsgTxt("Input argument 2 is not a string.\n");
		params->_extra_content = mxCalloc(mxGetN(prhs[2]) + 1, sizeof(char));
		mxGetString(prhs[2], params->_extra_content, mxGetN(prhs[2]) + 1);

		params->_sizex = 0;
		params->_sizey = 0;

#ifdef __DEBUG_MESSAGES
		mexPrintf ("porter from %s to %s\n", params->_portname, params->_extra_content);
#endif
	}
	else
		return -1;

	return 0;
}

///
///
///
void post_dispatcher (char *operation, _dispatchParams *params)
{
	if (strncmp(operation, "list", 4) == 0)
	{
		if (params->_extra_content != NULL)
			mexPrintf ("%s", params->_extra_content);
	}
}

void freeParams (char *operation, _dispatchParams *params)
{
	if (params != NULL)
	{
		if (params->_portname != NULL) mxFree(params->_portname);
		if (params->_protocol != NULL) mxFree(params->_protocol);
		if (params->_network != NULL) mxFree(params->_network);

		/// for read do not clear mem since it's just a pointer to the port's content.
		if (strncmp(operation, "read", 4) != 0 && strncmp(operation, "write", 5) != 0)
		{
			if (params->_extra_content != NULL) mxFree(params->_extra_content);
		}

		mxFree(params);
	}
}

///
///
///
int cell_in_bytes (mxArray* cell)
{
	/// skip first element.
	mxArray *tx = NULL;
	int nelem = mxGetNumberOfElements(cell);
	int i = 0; 
	int count = 0;

	for (i = 1; i < nelem; i++)
	{
		tx = mxGetCell (cell, i);
		count += sizeof(enum __YBTypeCodes);

		switch (mxGetClassID(tx))
		{
		case mxCHAR_CLASS:
			/// string.
			count += (mxGetNumberOfElements(tx) + 1);
			count += sizeof(int);
			break;

		case mxDOUBLE_CLASS:
			count += (mxGetNumberOfElements(tx) * sizeof(double));
			if (mxGetNumberOfElements(tx) > 1)
				count += sizeof(int);
			/// numeric.
			break;

		default:
			mexErrMsgTxt("Unrecognized bottle field.\n");
			break;
		}
	}

	return count;
}

///
///
///
char *cell_to_bottle (mxArray* cell, int *len, char **id)
{
	char *text, *ptr;
	mxArray *tx;
	int i;
	int nelem;

	tx = mxGetCell (cell, 0);
	if (mxGetClassID(tx) != mxCHAR_CLASS)
		mexErrMsgTxt("Bottle ID field (1) must be a string.\n");

	*id = mxCalloc (1, mxGetNumberOfElements(tx) + 1);
	mxGetString (tx, *id, mxGetNumberOfElements(tx) + 1);

	/// terminates the string with a 0.
	ptr = text = mxCalloc (1, cell_in_bytes(cell));
	
	nelem = mxGetNumberOfElements(cell);
	for (i = 1; i < nelem; i++)
	{
		tx = mxGetCell (cell, i);

		switch (mxGetClassID(tx))
		{
		case mxCHAR_CLASS:
			/// string.
			*((enum __YBTypeCodes *)ptr) = YBTypeString;
			ptr += sizeof(enum __YBTypeCodes);
			*((int *)ptr) = mxGetNumberOfElements(tx) + 1;
			ptr += sizeof(int);
			mxGetString (tx, ptr, mxGetNumberOfElements(tx));
			ptr += (mxGetNumberOfElements(tx) + 1);
			break;

		case mxDOUBLE_CLASS:
			if (mxGetNumberOfElements(tx) == 1)
			{
				/// numeric.
				*((enum __YBTypeCodes *)ptr) = YBTypeDouble;
				ptr += sizeof(enum __YBTypeCodes);
				*((double *)ptr) = mxGetScalar (tx);
				ptr += sizeof(double);
			}
			else
			{
				/// vector (YVector).
				*((enum __YBTypeCodes *)ptr) = YBTypeYVector;
				ptr += sizeof(enum __YBTypeCodes);
				*((int *)ptr) = mxGetNumberOfElements(tx);
				ptr += sizeof(int);
				memcpy (ptr, mxGetPr(tx), sizeof(double) * mxGetNumberOfElements(tx));
				ptr += (mxGetNumberOfElements(tx) * sizeof(double));
			}
			break;

		default:
			mexErrMsgTxt("Unrecognized bottle field in cell_to_bottle.\n");
			break;
		}
	}

	*len = (int)(ptr-text); 
	return text;
}

///
///
///
int scan_bottle (char *text, int top)
{
	int count = 0;
	int ptr = 0, tmp = 0;

	while (ptr < top)
	{
		switch (*(enum __YBTypeCodes *)(text + ptr))
		{
		case YBTypeChar:
			ptr += sizeof(enum __YBTypeCodes);
			ptr += 1;
			break;

		case YBTypeInt:
			ptr += sizeof(enum __YBTypeCodes);
			ptr += sizeof(int);
			break;

		case YBTypeDouble:
			ptr += sizeof(enum __YBTypeCodes);
			ptr += sizeof(double);
			break;

		case YBTypeYVector:
			ptr += sizeof(enum __YBTypeCodes);
			tmp = *(int *)(text + ptr);
			ptr += sizeof(int);
			ptr += (sizeof(double) * tmp);
			break;

		case YBTypeVocab:
		case YBTypeString:
			ptr += sizeof(enum __YBTypeCodes);
			tmp = *(int *)(text + ptr);
			ptr += (sizeof(int) + tmp);
			break;

		default:
			///
			mexErrMsgTxt("Unrecognized bottle field.\n");
			break;
		}

		count ++;
	}

	return count;
}


int fill_bottle(mxArray *cell, char *text, int nelem)
{
	int i;
	int ptr = 0, tmp = 0;
	mxArray *tx = NULL;
	double *pp = NULL;

	for (i = 1; i < nelem; i ++)
	{
		switch (*(enum __YBTypeCodes *)(text + ptr))
		{
		case YBTypeChar:
			ptr += sizeof(enum __YBTypeCodes);
			mxSetCell (cell, i, mxCreateDoubleScalar(text[ptr]));
			ptr += 1;
			break;

		case YBTypeInt:
			ptr += sizeof(enum __YBTypeCodes);
			mxSetCell (cell, i, mxCreateDoubleScalar(*(int *)(text + ptr)));
			ptr += sizeof(int);
			break;

		case YBTypeDouble:
			ptr += sizeof(enum __YBTypeCodes);
			mxSetCell (cell, i, mxCreateDoubleScalar(*(double *)(text + ptr)));
			ptr += sizeof(double);
			break;

		case YBTypeYVector:
			ptr += sizeof(enum __YBTypeCodes);
			tmp = *(int *)(text + ptr);
			ptr += sizeof(int);
			tx = mxCreateDoubleMatrix(1, tmp, mxREAL);
			pp = mxGetPr (tx);
			memcpy (pp, text + ptr, sizeof(double) * tmp);
			mxSetCell (cell, i, tx);
			ptr += (sizeof(double) * tmp);
			break;

		case YBTypeVocab:
		case YBTypeString:
			ptr += sizeof(enum __YBTypeCodes);
			tmp = *(int *)(text + ptr);
			ptr += sizeof(int);
			mxSetCell (cell, i, mxCreateString(text + ptr));
			ptr += tmp;
			break;

		default:
			///
			mexErrMsgTxt("Unrecognized bottle field.\n");
			break;
		}
	}

	return 0;
}


///
///
///
void image_to_array (mxArray* img, char *array, int padding, int type)
{
	unsigned char *tmp = NULL;
	float *ftmp = NULL;
	int *itmp = NULL;
	float *farray = NULL;
	int *iarray = NULL;
	int m, n;	/// index m = rows, n = cols.
	int nrows, ncols;

	switch (type)
	{
	case YARP_PIXEL_MONO:
	case YARP_PIXEL_MONO_SIGNED:
		tmp = mxGetData(img);
		nrows = mxGetM(img);
		ncols = mxGetN(img);

		for (m = 0; m < nrows; m++)
		{
			for (n = 0; n < ncols; n++)
			{
				*(tmp + n * nrows + m) = *array++;
			}

			array += padding;
		}
		break;

	case YARP_PIXEL_RGB:
	case YARP_PIXEL_HSV:
	case YARP_PIXEL_BGR:
	case YARP_PIXEL_RGB_SIGNED:
		tmp = mxGetData(img);
		nrows = mxGetM(img);
		ncols = mxGetN(img) / 3;

		for (m = 0; m < nrows; m++)
		{
			for (n = 0; n < ncols; n++)
			{
				*(tmp + n * nrows + m) = *array++;
				*(tmp + ncols*nrows + n * nrows + m) = *array++;
				*(tmp + 2*ncols*nrows + n * nrows + m) = *array++;
			}

			array += padding;
		}
		break;

	case YARP_PIXEL_MONO_FLOAT:
		farray = (float *)array;
		ftmp = mxGetData(img);
		nrows = mxGetM(img);
		ncols = mxGetN(img);

		for (m = 0; m < nrows; m++)
		{
			for (n = 0; n < ncols; n++)
			{
				*(ftmp + n * nrows + m) = *farray++;
			}

			farray = (float *)(((char *)farray) + padding);
		}
		break;

	case YARP_PIXEL_RGB_FLOAT:
	case YARP_PIXEL_HSV_FLOAT:
		farray = (float *)array;
		ftmp = mxGetData(img);
		nrows = mxGetM(img);
		ncols = mxGetN(img) / 3;

		for (m = 0; m < nrows; m++)
		{
			for (n = 0; n < ncols; n++)
			{
				*(ftmp + n * nrows + m) = *farray++;
				*(ftmp + ncols*nrows + n * nrows + m) = *farray++;
				*(ftmp + 2*ncols*nrows + n * nrows + m) = *farray++;
			}

			farray = (float *)(((char *)farray) + padding);
		}
		break;

	case YARP_PIXEL_INT:
		iarray = (int *)array;
		itmp = mxGetData(img);
		nrows = mxGetM(img);
		ncols = mxGetN(img);

		for (m = 0; m < nrows; m++)
		{
			for (n = 0; n < ncols; n++)
			{
				*(itmp + n * nrows + m) = *iarray++;
			}

			iarray = (int *)(((char *)farray) + padding);
		}
		break;

	default:
		mexErrMsgTxt("Unrecognized image type (or not supported by this code!).\n");
		break;
	}
}

void fillOutput (char *operation, int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[], _dispatchParams *params, int return_value)
{
	double *v = NULL;
	int nelem = 0;
	int pixid = 0;
	int padding = 0;
	int dims[3];

	if (return_value < 0)
	{
		plhs[0] = mxCreateScalarDouble(0);
		if (nlhs == 2)
			plhs[1] = mxCreateScalarDouble(return_value);
	}
	else
	if (strncmp(operation, "read", 4) == 0)
	{
		switch (params->_type)
		{
		case MX_YARP_INT:
			plhs[0] = mxCreateScalarDouble((double)(*(int *)params->_extra_content));
			if (nlhs == 2)
			{
				plhs[1] = mxCreateScalarDouble(return_value);
			}
			break;

		case MX_YARP_DOUBLE:
			plhs[0] = mxCreateScalarDouble((double)(*(double *)params->_extra_content));
			if (nlhs == 2)
			{
				plhs[1] = mxCreateScalarDouble(return_value);
			}
			break;

		case MX_YARP_FLOAT:
			plhs[0] = mxCreateScalarDouble((double)(*(float *)params->_extra_content));
			if (nlhs == 2)
			{
				plhs[1] = mxCreateScalarDouble(return_value);
			}
			break;

		case MX_YARP_YVECTOR:
			/// fills the vector here.
			plhs[0] = mxCreateDoubleMatrix (1, params->_sizex, mxREAL);
			v = mxGetPr(plhs[0]);
			memcpy (v, params->_extra_content, sizeof(double) * params->_sizex);
			
			if (nlhs == 2)
			{
				plhs[1] = mxCreateScalarDouble(return_value);
			}
			break;

		case MX_YARP_BOTTLE:
			/// portname contains the ID of the bottle (a string).
			nelem = scan_bottle(params->_extra_content, params->_sizex) + 1;
			plhs[0] = mxCreateCellMatrix (1, nelem);
			if (nlhs == 2)
				plhs[1] = mxCreateScalarDouble(return_value);

			mxSetCell (plhs[0], 0, mxCreateString (params->_portname));
			fill_bottle (plhs[0], params->_extra_content, nelem);
			params->_portname = NULL;
			break;

		///
		///
		/// IMAGE type, with subtypes.
		case MX_YARP_IMAGE:
			pixid = (params->_extra_params & 0x0000ffff);
			padding = (params->_extra_params & 0xffff0000) >> 16;

			/// negative pixid are not really supported (never used but possible).
			switch (pixid)
			{
			case YARP_PIXEL_INVALID:
			default:
				mexErrMsgTxt("Unrecognized pixel type in recv image.\n");
				break;

			case YARP_PIXEL_MONO:
				dims[0] = params->_sizey;
				dims[1] = params->_sizex;
				plhs[0] = mxCreateNumericArray (2, dims, mxUINT8_CLASS, mxREAL);

				image_to_array (plhs[0], params->_extra_content, padding, YARP_PIXEL_MONO);
				///memcpy (mxGetData(plhs[0]), params->_extra_content, dims[0]*dims[1]);
			
				break;

			case YARP_PIXEL_RGB:
			case YARP_PIXEL_HSV:
			case YARP_PIXEL_BGR:
				dims[0] = params->_sizey;
				dims[1] = params->_sizex + padding;
				dims[2] = 3;
				plhs[0] = mxCreateNumericArray (3, dims, mxUINT8_CLASS, mxREAL);

				image_to_array (plhs[0], params->_extra_content, padding, YARP_PIXEL_RGB);

				break;

			case YARP_PIXEL_MONO_SIGNED:
				dims[0] = params->_sizey;
				dims[1] = params->_sizex + padding;
				plhs[0] = mxCreateNumericArray (2, dims, mxINT8_CLASS, mxREAL);

				image_to_array (plhs[0], params->_extra_content, padding, YARP_PIXEL_MONO_SIGNED);
			
				break;

			case YARP_PIXEL_RGB_SIGNED:
				dims[0] = params->_sizey;
				dims[1] = params->_sizex + padding;
				dims[2] = 3;
				plhs[0] = mxCreateNumericArray (3, dims, mxINT8_CLASS, mxREAL);

				image_to_array (plhs[0], params->_extra_content, padding, YARP_PIXEL_RGB_SIGNED);

				break;
				
			case YARP_PIXEL_MONO_FLOAT:
				dims[0] = params->_sizey;
				dims[1] = params->_sizex + padding;

				/// potential mismatch between float and SINGLE type.
				plhs[0] = mxCreateNumericArray (2, dims, mxSINGLE_CLASS, mxREAL);

				image_to_array (plhs[0], params->_extra_content, padding, YARP_PIXEL_MONO_FLOAT);
			
				break;

			case YARP_PIXEL_RGB_FLOAT:
			case YARP_PIXEL_HSV_FLOAT:
				dims[0] = params->_sizey;
				dims[1] = params->_sizex + padding;
				dims[2] = 3;
				plhs[0] = mxCreateNumericArray (3, dims, mxSINGLE_CLASS, mxREAL);

				image_to_array (plhs[0], params->_extra_content, padding, YARP_PIXEL_RGB_FLOAT);

				break;


			case YARP_PIXEL_INT:
				dims[0] = params->_sizey;
				dims[1] = params->_sizex + padding;
				plhs[0] = mxCreateNumericArray (2, dims, mxINT32_CLASS, mxREAL);

				image_to_array (plhs[0], params->_extra_content, padding, YARP_PIXEL_INT);
			
				break;
			}
			if (nlhs == 2)
				plhs[1] = mxCreateScalarDouble(return_value);

			break;

		default:
			mexPrintf ("troubles, shouldn't be executing this\n");
			prhs[0] = mxCreateScalarDouble(0);
			if (nlhs == 2)
				plhs[1] = mxCreateScalarDouble(-1);
			break;
		}
	}
	else
	{
		plhs[0] = mxCreateScalarDouble(return_value);
		if (nlhs == 2)
			plhs[1] = mxCreateScalarDouble(return_value);
	}
}

///
///
///
static void cleanup(void)
{
#ifdef __DEBUG_MESSAGES
	mexPrintf("cleaning up\n");
#endif
	cleanUpList();
}

///
///	EXAMPLES:
///		p = port('create', 'int', 0);							/// creates an out port of type int.
///		ans = port('register', p, '/matlab/test', 'default');	/// registers port <p> into the name server.
///		ans = port('unregister', p);							/// unregisters port <p> from the name server.
///		ans = port('destroy', p);								/// calls the port destructor.
///		ans = port('list');										/// lists the ports in the internal structure.
///		[ans, datum] = port('read', p, wait);					/// reads from port <p> and return data in <datum>, <wait> optional flag blocking/non.
///		ans = port('write', p, datum);							/// writes to port <p> data in <datum>.
///

///
///
/// MEX function entry point.
///
void mexFunction(
	int nlhs,              // Number of left hand side (output) arguments
	mxArray *plhs[],       // Array of left hand side arguments
	int nrhs,              // Number of right hand side (input) arguments
	const mxArray *prhs[]  // Array of right hand side arguments
)
{
	/// <1> is a string containing the name of the operation on port (e.g. create, destroy, etc).
	/// <2> a list of various things.
	///
	///		create: type of data, direction
	///			returns a small integer to identify the port later on, -1 on failure.
	///		register: port name, network name
	///			returns -1 on failure.
	///		unregister: none
	///			returns -1 on failure.
	///		destroy: none
	///			returns -1 on failure.
	///		list: none
	///			prints the internal list of ports.
	///		read: port entry, and blocking flag
	///			returns the data read from the port and the failure code (2 params).
	///		write: port entry and data to write
	///			returns -1 on failure.
	///

	char *operation = NULL;
	_dispatchParams *params = NULL;
	int buflen = 0;
	int return_value = -1;

	///
	/// sets the mex cleanup function.
	mexAtExit(cleanup);

	if (nrhs < 1)
		mexErrMsgTxt("Not enough input parameters to do anything.\n");

	if (mxIsChar(prhs[0]) != 1 || mxGetNumberOfDimensions(prhs[0]) != 2 || mxGetM(prhs[0]) != 1)
		mexErrMsgTxt("1st parameter must be a string.\n");
    
	buflen = mxGetN(prhs[0]) + 1;
	operation = mxCalloc(buflen, sizeof(char));
	mxGetString(prhs[0], operation, buflen);

	params = mxCalloc(1, sizeof(_dispatchParams));

	/// since I now know the operation, I can try reading the params.
	return_value = fillParams (operation, nlhs, plhs, nrhs, prhs, params);
	if (return_value < 0)
		mexErrMsgTxt("one parameter is wrong, can't call dispatcher function.\n");

	/// call the C++ dispatcher.
	return_value = dispatcher (operation, (void *)params);

	/// call a post processing routine, to complete any unfinished business.
	post_dispatcher (operation, params);

	/// fills the output arrays (and alloc them appropriately).
	fillOutput (operation, nlhs, plhs, nrhs, prhs, params, return_value);

	/// free memory before leaving.
	freeParams (operation, params);

	mxFree (operation);

	return;
}


