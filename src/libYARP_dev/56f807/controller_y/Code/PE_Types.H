/** ###################################################################
**     THIS BEAN MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename  : PE_Types.H
**     Project   : controller_y
**     Processor : 56F807
**     Beantype  : PE_Types
**     Version   : Driver 01.02
**     Compiler  : Metrowerks DSP C Compiler
**     Date/Time : 12/14/2004, 2:35 PM
**     Abstract  :
**         This bean "PE_Types" contains internal definitions
**         of the types.
**     Settings  :
**     Contents  :
**         No public methods
**
**     (c) Copyright UNIS, spol. s r.o. 1997-2002
**     UNIS, spol. s r.o.
**     Jundrovska 33
**     624 00 Brno
**     Czech Republic
**     http      : www.processorexpert.com
**     mail      : info@processorexpert.com
** ###################################################################*/

#ifndef __PE_Types_H
#define __PE_Types_H

#define  FALSE  0
#define  TRUE   1

#ifndef NULL
  #define  NULL   0
#endif

/* PE types definition */
typedef unsigned char bool;
typedef unsigned char byte;
typedef unsigned int word;
typedef unsigned long dword;
typedef unsigned long dlong[2];

/* SDK types definition */
typedef char           Word8;
typedef unsigned char  UWord8;
typedef short          Word16;
typedef unsigned short UWord16;
typedef long           Word32;
typedef unsigned long  UWord32;
typedef char           Int8;
typedef unsigned char  UInt8;
typedef int            Int16;
typedef unsigned int   UInt16;
typedef long           Int32;
typedef unsigned long  UInt32;
typedef __typeof__(sizeof(0)) ssize_t;

/* PE register access macros */
#define setRegBit(reg, bit)              reg |= reg##_##bit##_##MASK
#define clrRegBit(reg, bit)              reg &= ~reg##_##bit##_##MASK
#define getRegBit(reg, bit)              (reg & reg##_##bit##_##MASK)
#define setReg(reg, val)                 reg = val
#define getReg(reg)                      reg
#define setRegBits(reg, mask)            reg |= mask
#define getRegBits(reg, mask)            (reg & (mask))
#define clrRegBits(reg, mask)            reg &= ~(mask)
#define setRegBitGroup(reg, bits, val)   reg = ((reg & ~reg##_##bits##_##MASK) | ((val) << reg##_##bits##_##BITNUM))
#define getRegBitGroup(reg, bits)        ((reg & reg##_##bits##_##MASK) >> reg##_##bits##_##BITNUM)
#define setRegMask(reg, maskAnd, maskOr) reg = (getReg(reg) & ~maskAnd) | maskOr
#define setRegBitVal(reg, bit, val) {\
                                      if (val==0)\
                                        reg &= ~reg##_##bit##_##MASK;\
                                      else\
                                        reg |= reg##_##bit##_##MASK;\
                                    }
#define changeRegBits(reg, mask)         reg ^= mask
#define changeRegBit(reg, bit)           reg ^= reg##_##bit##_##MASK


/* a direct address read, result is thrown away */
inline void periphMemDummyRead(register volatile UWord16* addr)
{
        register UWord16 reg;
        //asm { move X:(addr),reg }
}
/* set group of bits using two non-interruptible instructions (set,reset) */
#define periphBitGrpSR(GroupMask, Mask, Addr) { \
        *(Addr) |= ((Mask) & (GroupMask));        /* set "one" bits */ \
        *(Addr) &= ~((~(Mask)) & (GroupMask)); }  /* clear "zero" bits */
/* set group of bits using two non-interruptible instructions (reset,set) */
#define periphBitGrpRS(GroupMask, Mask, Addr) { \
        *(Addr) &= ~((~(Mask)) & (GroupMask));  /* clear "zero" bits */ \
        *(Addr) |= ((Mask) & (GroupMask)); }    /* set "one" bits */
/* set group of bits using two non-interruptible instructions (zero,set) */
#define periphBitGrpZS(GroupMask, Mask, Addr) { \
        *(Addr) &= ~(GroupMask);               /* clear all bits in group */ \
        *(Addr) |= ((Mask) & (GroupMask)); }   /* set "one" bits */
/**/
#define in16(var,l,h)  var = ((word)(l)) | (((word)(h)) << 8)
#define out16(l,h,val) { l = (byte)val; h = (byte)(val >> 8); }

#define output(P, V) setReg(P,V)
#define input(P) getReg(P)

#define __EI0() { asm(bfset  #0x0100,SR); asm(bfclr  #0x0200,SR); } /* Enable interrupts of level 0,1 */
#define __EI(level)  __EI0()           /* Enable interrupts of level 0,1 */
#define __DI() { asm(bfset  #0x0300,SR); } /* Disable interrupts, only level 1 is allowed */

#define SaveStatusReg()     { asm(move SR,SR_reg); asm(bfset  #0x0300,SR); asm(nop); asm(nop); } /* Save status register and disable interrupts */
#define RestoreStatusReg()  { asm(move SR_reg,SR); asm(nop); asm(nop); } /* Restore status register  */
#define EnterCritical()     { if (++SR_lock == 1) SaveStatusReg(); } /* Save status register and disable interrupts */
#define ExitCritical()      { if (--SR_lock == 0) RestoreStatusReg(); } /* Restore status register  */

typedef struct {          /* Black&White Image  */
  word width;             /* Image width  */
  word height;            /* Image height */
  byte *pixmap;           /* Image pixel bitmap */
  word size;              /* Image size   */
  char *name;             /* Image name   */
} TIMAGE;
typedef TIMAGE* PIMAGE ; /* Pointer to image */

/* 16-bit register (Motorola format - big endian) */
typedef union {
   word w;
   struct {
     byte high,low;
   } b;
} TWREG;

typedef union
{
        struct
        {
          UWord16 LSBpart;
          Word16 MSBpart;
        } RegParts;

        Word32 Reg32bit;

} decoder_uReg32bit;

typedef struct
{
        union { Word16 PositionDifferenceHoldReg;
                Word16 posdh; };
        union { Word16 RevolutionHoldReg;
                Word16 revh; };
        union { decoder_uReg32bit PositionHoldReg;
                Word32 posh; };

}decoder_sState;

typedef struct
{
        UWord16 EncPulses;
        UWord16 RevolutionScale;

        Int16   scaleDiffPosCoef;
        UInt16  scalePosCoef;
        Int16   normDiffPosCoef;
        Int16   normPosCoef;
}decoder_sEncScale;

typedef struct
{
        UWord16 Index    :1;
        UWord16 PhaseB   :1;
        UWord16 PhaseA   :1;
        UWord16 Reserved :13;
}decoder_sEncSignals;

typedef union{
        decoder_sEncSignals  EncSignals;
        UWord16 Value;
} decoder_uEncSignals;

/******************************************************************************
*
* This Motor Control section contains generally useful and generic
* types that are used throughout the domain of motor control.
*
******************************************************************************/
/* Fractional data types for portability */
typedef short          Frac16;
typedef long           Frac32;

typedef enum
{
        mcPhaseA,
        mcPhaseB,
        mcPhaseC
} mc_ePhaseType;

typedef struct
{
        Frac16 PhaseA;
        Frac16 PhaseB;
        Frac16 PhaseC;
} mc_s3PhaseSystem;

/* general types, primary used in FOC */

typedef struct
{
        Frac16 alpha;
        Frac16 beta;
} mc_sPhase;

typedef struct
{
        Frac16 sine;
        Frac16 cosine;
} mc_sAngle;

typedef struct
{
        Frac16 d_axis;
        Frac16 q_axis;
} mc_sDQsystem;

typedef struct
{
        Frac16 psi_Rd;
        Frac16 omega_field;
        Frac16 i_Sd;
        Frac16 i_Sq;
} mc_sDQEstabl;

typedef UWord16 mc_tPWMSignalMask;    /*  pwm_tSignalMask contains six control bits
                                          representing six PWM signals, shown below.
                                          The bits can be combined in a numerical value
                                          that represents the union of the appropriate
                                          bits.  For example, the value 0x15 indicates
                                          that PWM signals 0, 2, and 4 are set.
                                      */

#define MC_PWM_SIGNAL_0       0x0001
#define MC_PWM_SIGNAL_1       0x0002
#define MC_PWM_SIGNAL_2       0x0004
#define MC_PWM_SIGNAL_3       0x0008
#define MC_PWM_SIGNAL_4       0x0010
#define MC_PWM_SIGNAL_5       0x0020
#define MC_PWM_NO_SIGNALS     0x0000     /* No (none) PWM signals */
#define MC_PWM_ALL_SIGNALS   (MC_PWM_SIGNAL_0 | \
                                                                        MC_PWM_SIGNAL_1 | \
                                                                        MC_PWM_SIGNAL_2 | \
                                                                        MC_PWM_SIGNAL_3 | \
                                                                        MC_PWM_SIGNAL_4 | \
                                                                        MC_PWM_SIGNAL_5)

/* general types, primary used in PI, PID and other controllers */

typedef struct
{
   Word16 ProportionalGain;
   Word16 ProportionalGainScale;
   Word16 IntegralGain;
   Word16 IntegralGainScale;
   Word16 DerivativeGain;
   Word16 DerivativeGainScale;
   Word16 PositivePIDLimit;
   Word16 NegativePIDLimit;
   Word16 IntegralPortionK_1;
   Word16 InputErrorK_1;
}mc_sPIDparams;

typedef struct
{
   Word16 ProportionalGain;
   Word16 ProportionalGainScale;
   Word16 IntegralGain;
   Word16 IntegralGainScale;
   Word16 PositivePILimit;
   Word16 NegativePILimit;
   Word16 IntegralPortionK_1;
}mc_sPIparams;

#endif /* __PE_Types_H */

/*
** ###################################################################
**
**     This file was created by UNIS Processor Expert 03.32 for 
**     the Motorola 56800 series of microcontrollers.
**
** ###################################################################
*/
