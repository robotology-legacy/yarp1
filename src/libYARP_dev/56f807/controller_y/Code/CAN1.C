/** ###################################################################
**     THIS BEAN MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename  : CAN1.C
**     Project   : controller_y
**     Processor : 56F807
**     Beantype  : MotorolaCAN
**     Version   : Bean 02.259, Driver 01.01, CPU db: 2.71.191
**     Compiler  : Metrowerks DSP C Compiler
**     Date/Time : 1/17/2005, 1:23 PM
**     Abstract  :
**         This bean "MotorolaCAN" implements an CAN serial channel.
**     Settings  :
**         CAN channel                 : MSCAN
**
**         Protocol
**             Time segment 1          : 10
**             Time segment 2          : 7
**             RSJ                     : 1
**
**             Recieve accept. code    : 0
**             Recieve accept. mask    : 0
**
**
**     Contents  :
**         SetAcceptanceCode - byte CAN1_SetAcceptanceCode(dword Mask);
**         SetAcceptanceMask - byte CAN1_SetAcceptanceMask(dword Mask);
**         SetAcceptanceMode - byte CAN1_SetAcceptanceMode(byte Mode);
**         SendFrame         - byte CAN1_SendFrame(byte BufferNum,dword MessageID,byte FrameType,byte Length...
**         ReadFrame         - byte CAN1_ReadFrame(dword *MessageID,byte *FrameType,byte *FrameFormat,byte *...
**         GetStateTX        - byte CAN1_GetStateTX(void);
**         GetStateRX        - bool CAN1_GetStateRX(void);
**         GetError          - byte CAN1_GetError(CAN1_TError *Err);
**
**     (c) Copyright UNIS, spol. s r.o. 1997-2002
**     UNIS, spol. s r.o.
**     Jundrovska 33
**     624 00 Brno
**     Czech Republic
**     http      : www.processorexpert.com
**     mail      : info@processorexpert.com
** ###################################################################*/

/* MODULE CAN1. */

#include "CAN1.h"
#include "AS1.h"
#include "QD1.h"
#include "QD2.h"
#include "IFsh1.h"
#include "PWMC1.h"
#include "PWMC2.h"
#include "TI1.h"

#define CAN_MAX_DATA_LEN      8        /* Max number of data to be sent in one frame */
#define FULL_RX_BUF           1        /* RX buffer full           */

#define EXTENDED_FRAME_ID     2047     /* Max value of the standard frame ID */
#define MB_ID_IDE             0x00080000UL
#define CAN_TX_MBUFFERS       3        /* Number of TX buffers */

typedef struct {                       /* Message buffer structure */
          word IDR0;
          word IDR1;
          word IDR2;
          word IDR3;
          word Data[8];
          word DLR;
          word TBPR;
          word Reserved;
        }TMsgBuff;                     /* Message buffer structure */

const word TXMsgBuffer[CAN_TX_MBUFFERS] = { (word)&CAN_TB0_IDR0, (word)&CAN_TB1_IDR0, (word)&CAN_TB2_IDR0 }; /* TX message buffer addresses */

static byte ErrFlag;                   /* Error flags mirror of the status register */
static byte SerFlag;                   /* Flags for CAN communication */
                                       /* Bits: 0 - OverRun error */
                                       /*       1 - Framing error */
                                       /*       2 - Parity error */
                                       /*       3 - Full RX buffer */
                                       /*       4 - Full TX buffer */

/*
** ===================================================================
**     Method      :  Idr2Id (bean MotorolaCAN)
**
**     Description :
**         This method is internal. It is used by Processor Expert
**         only.
** ===================================================================
*/
static inline dword Idr2Id(dword idr)
{
  if (idr & MB_ID_IDE)
    return ((idr >> 1) & 0x3FFFFUL) | ((idr >> 3) & 0x1FFC0000); /* Extended frame */
  else
    return idr >> 21;                  /* Standard frame */
}

/*
** ===================================================================
**     Method      :  GetRxBufferIdr (bean MotorolaCAN)
**
**     Description :
**         This method is internal. It is used by Processor Expert
**         only.
** ===================================================================
*/
static inline dword GetRxBufferIdr()
{
  dword Idr;

  Idr = getReg(CAN_RB_IDR0);
  Idr <<= 8;
  Idr |= getReg(CAN_RB_IDR1);
  Idr <<= 8;
  Idr |= getReg(CAN_RB_IDR2);
  Idr <<= 8;
  Idr |= getReg(CAN_RB_IDR3);
  return Idr;
}

/*
** ===================================================================
**     Method      :  Id2Idr (bean MotorolaCAN)
**
**     Description :
**         This method is internal. It is used by Processor Expert
**         only.
** ===================================================================
*/
static inline dword Id2Idr(dword id)
{
  if (id > EXTENDED_FRAME_ID)
    return (((id & 0x1FFC0000UL) << 3) | 0x00180000UL | ((id & 0x0003FFFFUL) << 1)); /* Extended frame */
  else
    return id << 21;                   /* Standard frame */
}

/*
** ===================================================================
**     Method      :  SetTxBufferIdr (bean MotorolaCAN)
**
**     Description :
**         This method is internal. It is used by Processor Expert
**         only.
** ===================================================================
*/
static inline void SetTxBufferIdr(dword idr, TMsgBuff *TxBuff)
{
  TxBuff->IDR3 = idr & 0x00FF;
  idr >>=8;
  TxBuff->IDR2 = idr & 0x00FF;
  idr >>=8;
  TxBuff->IDR1 = idr & 0x00FF;
  idr >>=8;
  TxBuff->IDR0 = idr & 0x00FF;
}

/*
** ===================================================================
**     Method      :  CAN1_SetAcceptanceMode (bean MotorolaCAN)
**
**     Description :
**         Set a content of the acceptance mode register.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Mode            - Acceptance mode.
**                           Supported modes: 
**                           SINGLE_32_FILTER - Single 32-bit
**                           acceptance filter
**                           TWO_16_FILTER - Two 16-bit acceptance
**                           filter
**                           FOUR_8_FILTER - Four 8-bit acceptance
**                           filter
**                           FILTER_CLOSED - Filter closed
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
**                           ERR_DISABLED - This bean is disabled by
**                           user
** ===================================================================
*/
byte CAN1_SetAcceptanceMode(byte Mode)
{
  if (Mode > 3)                        /* Is mode parameter greater then 3 */
    return ERR_VALUE;                  /* If yes then error */
  setRegBit(CANCTL0, SFTRES);          /* Disable device */
  setRegBitGroup(CANIDAC, IDAM, Mode); /* Set acceptance mode of the receiver */
  clrRegBit(CANCTL0, SFTRES);          /* Start device */
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  CAN1_GetStateRX (bean MotorolaCAN)
**
**     Description :
**         Return a value of the reception complete flag.
**     Parameters  : None
**     Returns     :
**         ---             - Value of the receiver complete flag of
**                           the given buffer. 
**                           Possible values:
**                           FALSE - message buffer is empty
**                           TRUE - message buffer isn't empty
** ===================================================================
*/
byte CAN1_GetStateRX(void)
{
  return (getRegBit(CANRFLG, RXF) != 0)? 1:0; /* Return status of the RX buffer */
}

/*
** ===================================================================
**     Method      :  CAN1_SetAcceptanceCode (bean MotorolaCAN)
**
**     Description :
**         Set acceptance code register.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Mask            - Mask could be 11-bit for standard
**                           frame or 29-bit for extended frame
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
**                           ERR_DISABLED - This bean is disabled by
**                           user
** ===================================================================
*/
byte CAN1_SetAcceptanceCode(dword Mask)
{
  dword tmpMask;

  tmpMask = Mask;
  setRegBit(CANCTL0, SFTRES);          /* Disable device */
  setReg(CANIDAR0, (byte)tmpMask);     /* Set acceptance mask register */
  setReg(CANIDAR4, (byte)tmpMask);     /* Set acceptance mask register */
  tmpMask>>=8;
  setReg(CANIDAR1, (byte)tmpMask);     /* Set acceptance mask register */
  setReg(CANIDAR5, (byte)tmpMask);     /* Set acceptance mask register */
  tmpMask>>=8;
  setReg(CANIDAR2, (byte)tmpMask);     /* Set acceptance mask register */
  setReg(CANIDAR6, (byte)tmpMask);     /* Set acceptance mask register */
  tmpMask>>=8;
  setReg(CANIDAR3, (byte)tmpMask);     /* Set acceptance mask register */
  setReg(CANIDAR7, (byte)tmpMask);     /* Set acceptance mask register */
  clrRegBit(CANCTL0, SFTRES);          /* Start device */
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  CAN1_GetError (bean MotorolaCAN)
**
**     Description :
**         Return a content of the receiver flag register.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * Err             - Pointer to returned set of errors
**     Returns     :
**         ---             - Error code (if GetError did not succeed),
**                           possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
** ===================================================================
*/
byte CAN1_GetError(CAN1_TError *Err)
{
  register word Status = getReg(CANRFLG); /* Read the status register */

  /* CANRFLG: RWRNIF=1,TWRNIF=1,RERRIF=1,TERRIF=1,BOFFIF=1,OVRIF=1 */
  setReg(CANRFLG, 126);                /* Clear error interrupt flags */
  Err->err = 0;                        /* Clear all errors */
  Err->errName.BusOff = ((Status & CANRFLG_BOFFIF_MASK) != 0); /* Bus-Off state */
  Err->errName.TxPassive = ((Status & CANRFLG_TERRIF_MASK) != 0); /* Transmitter error */
  Err->errName.RxPassive = ((Status & CANRFLG_RERRIF_MASK) != 0); /* Receiver error */
  Err->errName.TxWarning = ((Status & CANRFLG_TWRNIF_MASK) != 0); /* Transmitter warning */
  Err->errName.RxWarning = ((Status & CANRFLG_RWRNIF_MASK) != 0); /* Receiver warning */
  Err->errName.OverRun = ((Status & CANRFLG_OVRIF_MASK) != 0); /* Receiver overrun */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  HWEnDi (bean MotorolaCAN)
**
**     Description :
**         This method is internal. It is used by Processor Expert
**         only.
** ===================================================================
*/
static void HWEnDi(void)
{
  clrRegBit(CANCTL0, SFTRES);          /* Start device */
}

/*
** ===================================================================
**     Method      :  CAN1_SetHigh (bean MotorolaCAN)
**
**     Description :
**         This method is internal. It is used by Processor Expert
**         only.
** ===================================================================
*/
void CAN1_SetHigh(void)
{
  setReg(CANBTR0, 65);                 /* Set the device timing register */
  setReg(CANBTR1, 122);                /* Set the device timing register */
  setRegBit(CANCTL1, CLKSRC);          /* Select the clock source from bus clock */
  HWEnDi();                            /* Enable/disable device according to status flags */
}

/*
** ===================================================================
**     Method      :  CAN1_SendFrame (bean MotorolaCAN)
**
**     Description :
**         Send a frame.
**     Parameters  :
**         NAME            - DESCRIPTION
**         BufferNum       - Number of the buffer.
**         MessageID       - Identification of the
**                           message
**         FrameType       - Type of frame
**                           DATA_FRAME - data frame
**                           REMOTE_FRAME - remote frame
**         Length          - Length of the frame in bytes (0..
**                           8)
**       * Data            - Pointer to data
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
**                           ERR_DISABLED - This bean is disabled by
**                           user
**                           ERR_VALUE - Some parameter is out of
**                           possible range
** ===================================================================
*/
byte CAN1_SendFrame(byte BufferNum,dword MessageID,byte FrameType,byte Length,byte *Data)
{
  register byte i;                     /* Temorary variables */
  register byte bufmask=((word)1 << BufferNum); /* Buffer mask */
  register TMsgBuff *MsgBuff;

  if ( (BufferNum > CAN_TX_MBUFFERS-1) || (Length > CAN_MAX_DATA_LEN) ) /* Is BufferNum greater than CAN_MAXBUFF or Length greater than CAN_MAX_DATA_LEN? */
    return ERR_VALUE;                  /* If yes then error */
  if (FrameType > REMOTE_FRAME)        /* Is FrameType other than REMOTE_FRAME or DATA_FRAME */
    return ERR_VALUE;                  /* If yes then error */
  if (!(getReg(CANTFLG) & bufmask))    /* Is the transmit buffer full? */
    return ERR_TXFULL;                 /* If yes then error */
  MsgBuff = (TMsgBuff *)TXMsgBuffer[BufferNum];
  SetTxBufferIdr(Id2Idr(MessageID), MsgBuff); /* Set the message ID */
  if (FrameType == DATA_FRAME) {       /* Is it a data frame? */
    for (i=0; i<Length; i++)
      MsgBuff->Data[i] = Data[i];      /* Store data to the transmit register */
    if (MessageID > EXTENDED_FRAME_ID) /* Is it the extended frame? */
      MsgBuff->IDR3 &= 254;            /* If no then set message type as "data frame" */
    else
      MsgBuff->IDR1 &= 239;            /* If yes then set message type as "data frame" */
  }
  else {                               /* Remote frame */
    if (MessageID > EXTENDED_FRAME_ID) /* Is it the extended frame? */
      MsgBuff->IDR3 |= 1;              /* If yes then set message type as "remote frame" */
    else
      MsgBuff->IDR1 |= 16;             /* If yes then set message type as "remote frame" */
  }
  MsgBuff->DLR = Length;               /* Set the length of the message */
  MsgBuff->TBPR = 0;                   /* Set the priority (high) */
  setReg(CANTFLG, bufmask);            /* Start transmission */
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  CAN1_ReadFrame (bean MotorolaCAN)
**
**     Description :
**         Read a frame.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * MessageID       - Pointer to the message
**                           indentification
**       * FrameType       - Pointer to a frame type
**                           DATA_FRAME - data frame
**                           REMOTE_FRAME - remote frame
**       * FrameFormat     - Pointer to a frame
**                           format
**                           STANDARD_FORMAT - standard frame 11-bits
**                           EXTENDED_FORMAT - extended frame 29-bits
**       * Length          - Pointer to length of the frame
**       * Data            - The buffer for received data
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
**                           ERR_DISABLED - This bean is disabled by
**                           user
**                           ERR_RXEMPTY - The receive buffer is empty
** ===================================================================
*/
byte CAN1_ReadFrame(dword *MessageID,byte *FrameType,byte *FrameFormat,byte *Length,byte *Data)
{
  byte i;                              /* Temporary variable */
  dword ID;                            /* Temporary variable */

  if (!getRegBit(CANRFLG, RXF))        /* Is the receive buffer empty? */
    return ERR_RXEMPTY;                /* If yes then error */
  ID = Idr2Id(GetRxBufferIdr());       /* Read the identification of the received message */
  if (ID > EXTENDED_FRAME_ID)          /* Is it the extended frame? */
    *FrameType = (getReg(CAN_RB_IDR3) & 1)? REMOTE_FRAME : DATA_FRAME; /* Result the frame type */
  else
    *FrameType = (getReg(CAN_RB_IDR1) & 16)? REMOTE_FRAME : DATA_FRAME; /* Result the frame type */
  *MessageID = ID;                     /* Result the identification */
  *FrameFormat = (getReg(CAN_RB_IDR1) & 8)? EXTENDED_FORMAT : STANDARD_FORMAT; /* Result the frame type */
  *Length = getReg(CAN_RB_DLR) & 15;   /* Result length of the message */
  if (*FrameType == DATA_FRAME) {      /* Is frame "data frame" */
    for (i=0; i<*Length; i++)
      Data[i] = *((byte *)&CAN_RB_DSR0 + i); /* Return received data */
  }
  setReg(CANRFLG, CANRFLG_RXF_MASK);   /* Reset the receiver interrupt request flag */
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  CAN1_Init (bean MotorolaCAN)
**
**     Description :
**         This method is internal. It is used by Processor Expert
**         only.
** ===================================================================
*/
void CAN1_Init(void)
{
  /* CANCTL0: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,RXFRM=0,RXACT=0,CSWAI=0,SYNCH=0,??=0,SLPAK=0,SLPRQ=0,SFTRES=1 */
  setReg(CANCTL0, 1);                  /* Set the control register */
  /* CANCTL1: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,CANE=1,??=0,??=0,??=0,??=0,LOOPB=0,WUPM=0,CLKSRC=0 */
  setReg(CANCTL1, 128);                /* Set the control register */
  setRegBitGroup(CANIDAC, IDAM, 0);    /* Set the acceptance mode */
  setReg(CANIDAR0, 0);                 /* Set the acceptance code */
  setReg(CANIDAR1, 0);                 /* Set the acceptance code */
  setReg(CANIDAR2, 0);                 /* Set the acceptance code */
  setReg(CANIDAR3, 0);                 /* Set the acceptance code */
  setReg(CANIDAR4, 0);                 /* Set the acceptance code */
  setReg(CANIDAR5, 0);                 /* Set the acceptance code */
  setReg(CANIDAR6, 0);                 /* Set the acceptance code */
  setReg(CANIDAR7, 0);                 /* Set the acceptance code */
  setReg(CANIDMR0, 0);                 /* Set the acceptance mask */
  setReg(CANIDMR1, 0);                 /* Set the acceptance mask */
  setReg(CANIDMR2, 0);                 /* Set the acceptance mask */
  setReg(CANIDMR3, 0);                 /* Set the acceptance mask */
  setReg(CANIDMR4, 0);                 /* Set the acceptance mask */
  setReg(CANIDMR5, 0);                 /* Set the acceptance mask */
  setReg(CANIDMR6, 0);                 /* Set the acceptance mask */
  setReg(CANIDMR7, 0);                 /* Set the acceptance mask */
  CAN1_SetHigh();                      /* Initial speed CPU mode is high */
}

/*
** ===================================================================
**     Method      :  CAN1_GetStateTX (bean MotorolaCAN)
**
**     Description :
**         Return a value of the transmission complete flags.
**     Parameters  : None
**     Returns     :
**         ---             - Content of the transmitter complete
**                           flag register.
** ===================================================================
*/
/*
byte CAN1_GetStateTX(void)

**      This method is implemented as a macro in the header module. **
*/

/*
** ===================================================================
**     Method      :  CAN1_SetAcceptanceMask (bean MotorolaCAN)
**
**     Description :
**         Set the acceptance mask registers.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Mask            - Mask could be 11-bit for standard
**                           frame or 29-bit for extended frame
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
**                           ERR_DISABLED - This bean is disabled by
**                           user
** ===================================================================
*/
byte CAN1_SetAcceptanceMask(dword Mask)
{
  dword tmpMask;

  tmpMask = Mask;
  setRegBit(CANCTL0, SFTRES);          /* Disable device */
  setReg(CANIDMR0, (byte)tmpMask);     /* Set acceptance mask register */
  setReg(CANIDMR4, (byte)tmpMask);     /* Set acceptance mask register */
  tmpMask>>=8;
  setReg(CANIDMR1, (byte)tmpMask);     /* Set acceptance mask register */
  setReg(CANIDMR5, (byte)tmpMask);     /* Set acceptance mask register */
  tmpMask>>=8;
  setReg(CANIDMR2, (byte)tmpMask);     /* Set acceptance mask register */
  setReg(CANIDMR6, (byte)tmpMask);     /* Set acceptance mask register */
  tmpMask>>=8;
  setReg(CANIDMR3, (byte)tmpMask);     /* Set acceptance mask register */
  setReg(CANIDMR7, (byte)tmpMask);     /* Set acceptance mask register */
  clrRegBit(CANCTL0, SFTRES);          /* Start device */
  return ERR_OK;                       /* OK */
}


/* END CAN1. */
/*
** ###################################################################
**
**     This file was created by UNIS Processor Expert 03.32 for 
**     the Motorola 56800 series of microcontrollers.
**
** ###################################################################
*/
