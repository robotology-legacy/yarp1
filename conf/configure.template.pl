#! /usr/bin/perl
#
# A bunch of functions to be used by YARP configuration scripts.
# Use: require 'thisfilename' to include these functions.
#
#

use Getopt::Long;
use File::Copy;

#
# YARP compatibility test.
#
sub check_os
{
	chomp ($ver = `ver`);
	chomp ($uname = `uname`);
	if (index ($ver, "Windows") < 0 && index ($uname, "CYGWIN") < 0 
	   && index ($uname, "Linux") < 0 && index ($uname, "QNX") < 0 && index ($uname, "Darwin") < 0)
	{
#		print "This is a Windows 2000/XP specific script\n";
		print "Your OS is not yet suppoorted by this script\n";
		print "Perhaps this procedure can be simply extended to "; 
		print "other OSes but for now, this is all experimental...\n";
		
		die "This script is specific to Windows 2000/XP, Cygwin, Linux, Darwin and Qnx6\n";
	}

	$exp_os = '';
	if (!($ver =~ /Windows/)) # no win
	{
		if ($uname =~ /CYGWIN/)
		{
			$exp_os = "winnt";
		}
		elsif ($uname =~ /Linux/)
		{
			$exp_os = "linux";	
		}
		elsif ($uname =~ /QNX/)
		{
			$exp_os = "qnx6";
		}
		elsif ($uname =~ /Darwin/)
		{
			$exp_os = "darwin";
		}
	}
	else
	{
		$exp_os = "winnt";
	}

	$exp_os;
}


#
# Loads the config file into a hash table.
#
sub load_config_file
{
	die "load_config_file requires exactly two arguments\n" if (@_ != 2);

	my ($options_ref, $config_file) = @_;

	open CONFIG, $config_file or die "Can't open config file $!";

	my $contextual;
	while (<CONFIG>)
	{
		chomp;
		if (/^\[(\w+)\]\s?/)
		{
			$contextual = $1;
		}
		elsif (/^([A-Za-z0-9_\$\/]+)= ?/)
		{
			my $word = $1;
			if ($' =~ /([A-Za-z0-9_\/\$\.]+)\s?/)
			{
				$options_ref->{$contextual."<-".$word} = $1;
			}
		}
	}

	close CONFIG;

	1;
}


#
# Takes an hash and creates a config file for YARP. 
#
sub save_config_file
{
	die "save_config_file requires exactly two arguments\n" if (@_ != 2);
	my ($options_ref, $config_file) = @_;

	open CONFIG, "> $config_file";
	select CONFIG;

	print "//\n";
	print "// This is an example of configuration file.\n";
	print "// - projects and include files are created relying on this options.\n";
	print "//\n";
	print "// Generated by <configure.pl>\n";
	print "//\n";

	my $context = '';
	foreach my $key (sort keys %$options_ref)
	{
		my $value = $options_ref->{$key};
		$key =~ /<-/;
		if ($context ne $`)
		{
			$context = $`;
			print "\n[$context]\n";
		}
		print "$'= $value\n";
	}

	select STDOUT;
	close CONFIG;

	1;
}


#
# Gets an option and stores it in a hash table.
#
sub get_option_hash
{
	die "get_option_hash requires exactly 5 parameters\n" if (@_ != 5);
	my ($key, $default_value, $message, $type) = @_;
	my $options_ref = $_[4];
	my $line = undef;

	$options_ref->{$key} = $default_value if (!exists($options_ref->{$key}));

	print "$message [$options_ref->{$key}] ";
	chomp($line = <STDIN>);
	$options_ref->{$key} = $line if (defined($line) && $line ne '');

	if ($type)
	{
		verify_bool ($key, $default_value, $options_ref);
	}

	0;
}

sub verify_bool
{
	my ($key, $default_value, $options_ref) = @_;
	my $value = $options_ref->{$key};

	if ($default_value =~ /\b[TtFf]\w*/)
	{
		if ($value =~ /\b[TtYy1]\w*/)
		{
			$options_ref->{$key} = "TRUE";
		}
		elsif ($value =~ /\b[FfNn0]\w*/)
		{
			$options_ref->{$key} = "FALSE";
		}
		else
		{
			$options_ref->{$key} = $default_value;
		}
	}
	elsif ($default_value =~ /\b[YyNn]\w*/)
	{
		if ($value =~ /\b[TtYy1]\w*/)
		{
			$options_ref->{$key} = "YES";
		}
		elsif ($value =~ /\b[FfNn0]\w*/)
		{
			$options_ref->{$key} = "NO";
		}
		else
		{
			$options_ref->{$key} = $default_value;
		}
	}
}


sub call_make_and_print
{
	my ($project, $operation) = @_;

	open MK, "make -f Makefile $operation"."|";
	while (<MK>)
	{
		print;
	}
	close MK;	
}


sub call_msdev_and_print
{
	my ($project, $version, $operation) = @_;

	open MSDEV, "msdev $project.dsp /MAKE \"$project - Win32 ".$version."\" /".$operation."|";
	while (<MSDEV>)
	{
		print;
	}
	close MSDEV;	
}


sub do_ext_compile
{
	my ($exe) = @_;

	$exe =~ /(^[\w\d\-\.\/]+)/;
	unless (-x $1)
	{
		chmod 0755, $1;
	}
	
	open TOOLS, "$exe|";
	while (<TOOLS>)
	{
		print;
	}
	close TOOLS;
}


return 1;
